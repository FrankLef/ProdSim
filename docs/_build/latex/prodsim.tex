%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{ProdSim}
\date{Dec 29, 2021}
\release{0.1.0}
\author{Tom Fuchs}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\noindent\sphinxincludegraphics[width=1.000\linewidth]{{logo}.png}


\bigskip\hrule\bigskip




\sphinxAtStartPar
ProdSim is a process\sphinxhyphen{}based discrete event simulation for production environments based on the
\sphinxhref{https://simpy.readthedocs.io/en/latest/}{SimPy} framework. The package is designed to generate large high\sphinxhyphen{}resolution
synthetic production data sets.

\sphinxAtStartPar
The characteristics of a production system are represented by three system components, namely machines, workpieces, and
a factory. These components interact with one another on the following three system layers:
\begin{itemize}
\item {} 
\sphinxAtStartPar
logistics

\item {} 
\sphinxAtStartPar
stations

\item {} 
\sphinxAtStartPar
processes

\end{itemize}

\sphinxAtStartPar
The bottom level, namely the process level, models elementary assembly or machining operations in which the properties
and behavior of the system components can be influenced. The middle level, namely the station level, maps the system’s
buffer stores and groups machines together into stations according to a workshop or line production. At the top level,
namely the layout level, workpieces are created by sources and removed by sinks. In addition, the material flow of
workpieces through the production process is described.

\sphinxAtStartPar
Users must define production processes in two input files. In a JSON file, all orders, stations, and the factory are
defined. In a Python script, the users specify the assembly and processing functions, the behavior of the sources and
sinks, as well as global functions and user\sphinxhyphen{}defined distributions for attribute values.

\sphinxAtStartPar
Additionally, the package offers functionalities for the visualization of passed production processes, verification of
input files, and methods for estimating the simulation runtime

\sphinxAtStartPar
The following code displays the typical usage of the package:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{prodsim} \PYG{k+kn}{import} \PYG{n}{Environment}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Create simulation Environment}
    \PYG{n}{env} \PYG{o}{=} \PYG{n}{Environment}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Read the input files}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{read\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/process.json}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/function.py}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Inspect and visualize the input data (optional)}
    \PYG{c+c1}{\PYGZsh{} env.inspect()}
    \PYG{c+c1}{\PYGZsh{} env.visualize()}

    \PYG{c+c1}{\PYGZsh{} Start the simulation}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{simulate}\PYG{p}{(}\PYG{n}{sim\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{10\PYGZus{}000}\PYG{p}{,} \PYG{n}{progress\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{max\PYGZus{}memory}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{bit\PYGZus{}type}\PYG{o}{=}\PYG{l+m+mi}{64}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} export the output data}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{data\PYGZus{}to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./data/output/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{remove\PYGZus{}column}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{item\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{keep\PYGZus{}original}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
How this documentation should be used:

\sphinxAtStartPar
The {\hyperref[\detokenize{source/API/api:api}]{\sphinxcrossref{\DUrole{std,std-ref}{API Reference}}}} chapter provides an overview of all methods and their attributes as well as the
corresponding data types. The  {\hyperref[\detokenize{source/Interface_files/interface:interface}]{\sphinxcrossref{\DUrole{std,std-ref}{Interface Files}}}} chapter describes the structure to be followed by the
input files. These two chapters are designed as a reference for specific content. In the final
{\hyperref[\detokenize{source/Examples/examples:examples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} chapter, examples are chronologically matched to the later simulation study and contain all
elementary features of the package. Since some modeling techniques are also explained, studying these examples is
recommended before conducting one’s own simulation study.


\bigskip\hrule\bigskip



\chapter{Table of Contents}
\label{\detokenize{index:table-of-contents}}

\section{API Reference}
\label{\detokenize{source/API/api:api-reference}}\label{\detokenize{source/API/api:api}}\label{\detokenize{source/API/api::doc}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{Environment}}}
\label{\detokenize{source/API/api:environment}}
\sphinxAtStartPar
The Environment class represents the central element of the library. All offered simulation functionalities are
available to the user in the methods through an object of this class. In addition, the environment controls all
program\sphinxhyphen{}internal method calls as well as access to the process data in the background.

\phantomsection\label{\detokenize{source/API/api:module-environment}}\index{module@\spxentry{module}!environment@\spxentry{environment}}\index{environment@\spxentry{environment}!module@\spxentry{module}}\index{Environment (class in environment)@\spxentry{Environment}\spxextra{class in environment}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{environment.}}\sphinxbfcode{\sphinxupquote{Environment}}}
\sphinxAtStartPar
Execution Environment for the event\sphinxhyphen{}based production simulation.
\index{clear\_env() (environment.Environment method)@\spxentry{clear\_env()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.clear_env}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear\_env}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Reinitialize the environment object between two different simulation runs.

\sphinxAtStartPar
After calling this method, a new process must be read in.

\end{fulllineitems}

\index{data\_to\_csv() (environment.Environment method)@\spxentry{data\_to\_csv()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.data_to_csv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_to\_csv}}}{\emph{\DUrole{n}{path\_to\_wd}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{remove\_column}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{keep\_original}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Exports the simulation data to csv files.

\sphinxAtStartPar
Creates a file for each simulation object, with columns containing object properties and general simulation
information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_to\_wd}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the target directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{remove\_column}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of labels whose columns are removed before saving

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_original}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Keep an additional original file without removed columns

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingData}} \textendash{} \sphinxcode{\sphinxupquote{simulate}} was not called before

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the passed folder does not exist, then the program creates it.
\end{sphinxadmonition}

\end{fulllineitems}

\index{data\_to\_hdf5() (environment.Environment method)@\spxentry{data\_to\_hdf5()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.data_to_hdf5}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{data\_to\_hdf5}}}{\emph{\DUrole{n}{path\_to\_wd}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Exports the simulation data to hdf5 files.

\sphinxAtStartPar
Creates a hdf5 file in which each simulation object is stored a group. The metadata (‘header’) of each
simulation object is stored in an attribute and the simulation data in datasets of size max\_memory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_to\_wd}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the target directory

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the hdf5 file

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingData}} \textendash{} \sphinxcode{\sphinxupquote{simulate}} was not called before

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the passed folder does not exist, then the program creates it.
\end{sphinxadmonition}

\end{fulllineitems}

\index{define\_process() (environment.Environment method)@\spxentry{define\_process()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.define_process}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{define\_process}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Launches an interactive web application to define a new production process.
This method initiates a local development app on a flask server on localhoast:8050.

\end{fulllineitems}

\index{inspect() (environment.Environment method)@\spxentry{inspect()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.inspect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inspect}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Checks the passed input files for errors of logical and syntactic nature.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingData}} \textendash{} \sphinxcode{\sphinxupquote{read\_files}} was not called, or the data read in does not contain the arrays
‘order’ and ‘station’

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This method is only a support and does not guarantee an error\sphinxhyphen{}free simulation run.
\end{sphinxadmonition}

\end{fulllineitems}

\index{read\_files() (environment.Environment method)@\spxentry{read\_files()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.read_files}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read\_files}}}{\emph{\DUrole{n}{path\_data\_file}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{path\_function\_file}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Reads in the process input files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_data\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the JSON file with the process data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{path\_function\_file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the py file with the function definitions

\end{itemize}

\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{FileNotFoundError}} \textendash{} Files could not be found

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingParameter}} \textendash{} The ‘order’ or ‘station’ array is not defined in the process file or an order or
station object has no name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{UndefinedFunction}} \textendash{} One of the referenced functions cannot be found in the function file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{UndefinedObject}} \textendash{} One of the referenced orders or stations cannot be found in the data file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{InvalidType}} \textendash{} The component list has an element that is not of type list, or the capacity of an order or
station is not of type int

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{InvalidValue}} \textendash{} The capacity of an order or station is not greater than zero

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{NotSupportedParameter}} \textendash{} One of the values of the user\sphinxhyphen{}defined factory attributes has an undefined
identifier

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{simulate() (environment.Environment method)@\spxentry{simulate()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{\DUrole{n}{sim\_time}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{track\_components}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{progress\_bar}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{max\_memory}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{2}}, \emph{\DUrole{n}{bit\_type}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{32}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Starts the simulation run.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sim\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Simulated time

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{track\_components}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of strings representing components whose process data is to be stored

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress\_bar}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Specifies whether a progress bar should be displayed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_memory}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Maximal size of a single a numpy data array {[}Mb{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bit\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Bit type with which the values are stored

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingData}} \textendash{} \sphinxcode{\sphinxupquote{read\_files}} was not called or the data read in does not contain ‘order’ or ‘station’

\end{description}\end{quote}

\end{fulllineitems}

\index{visualize() (environment.Environment method)@\spxentry{visualize()}\spxextra{environment.Environment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:environment.Environment.visualize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{visualize}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Launches an interactive web application to display the input data.
This method initiates a local development app on a flask server on localhoast:8050.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{MissingData}} \textendash{} \sphinxcode{\sphinxupquote{read\_files}} was not called or the data read in does not contain the ‘order’ or ‘station’
array

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This method initiates a local development app on a flask server on localhoast:8050.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{Estimator}}}
\label{\detokenize{source/API/api:estimator}}
\sphinxAtStartPar
The Estimator class offers some functionalities through which the runtime behavior of the simulation can be estimated.
Alternatively, a reference simulation with a short simulation time can be performed, and the measured simulation time
can be scaled proportionally. However, the function est\_function is especially useful for developing suitable process
functions.

\phantomsection\label{\detokenize{source/API/api:module-estimator}}\index{module@\spxentry{module}!estimator@\spxentry{estimator}}\index{estimator@\spxentry{estimator}!module@\spxentry{module}}\index{Estimator (class in estimator)@\spxentry{Estimator}\spxextra{class in estimator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:estimator.Estimator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{estimator.}}\sphinxbfcode{\sphinxupquote{Estimator}}}
\sphinxAtStartPar
Estimator for estimating the expected simulation time.
\index{est\_attribute() (estimator.Estimator method)@\spxentry{est\_attribute()}\spxextra{estimator.Estimator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:estimator.Estimator.est_attribute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{est\_attribute}}}{\emph{\DUrole{n}{distribution}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}tuple\DUrole{p}{{]}}}}, \emph{\DUrole{n}{num\_station}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{track}\DUrole{p}{:} \DUrole{n}{bool}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Estimates the time caused by additional attributes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distribution}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of attributes to be estimated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_station}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of stations that workpieces of the order under consideration pass through

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{track}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Indicates whether the order is being tracked

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Estimated additional simulation time for additional attributes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{est\_function() (estimator.Estimator method)@\spxentry{est\_function()}\spxextra{estimator.Estimator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:estimator.Estimator.est_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{est\_function}}}{\emph{\DUrole{n}{function}\DUrole{p}{:} \DUrole{n}{Callable}}, \emph{\DUrole{n}{num\_station}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{track}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{imports}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{objects}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{, }object\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{item\_attributes}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{, }list\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{machine\_attributes}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{, }list\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{factory\_attributes}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{[}}str\DUrole{p}{, }list\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Estimates the time caused by a specific function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} List of attributes to be estimated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_station}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of stations at which the process function is called

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{track}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Indicates whether the order is being tracked

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{imports}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of all used import statements

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{objects}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of all used objects

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{item\_attributes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of all item attributes used in the function

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{machine\_attributes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of all machine attributes used in the function

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{factory\_attributes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} List of all factory attributes used in the function

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{InvalidFunction}} \textendash{} Function name is ‘function1’

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Estimated time for a single function call

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{est\_item() (estimator.Estimator method)@\spxentry{est\_item()}\spxextra{estimator.Estimator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:estimator.Estimator.est_item}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{est\_item}}}{\emph{\DUrole{n}{track}\DUrole{p}{:} \DUrole{n}{bool}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Estimates the time for creating a workpiece.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{track}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Indicates whether the order is being tracked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Estimated simulation time for creating a workpiece without attributes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{est\_station() (estimator.Estimator method)@\spxentry{est\_station()}\spxextra{estimator.Estimator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/API/api:estimator.Estimator.est_station}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{est\_station}}}{\emph{\DUrole{n}{track}\DUrole{p}{:} \DUrole{n}{bool}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Estimates the time caused by the recursive process logic.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{track}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Indicates whether the order is being tracked

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Estimated simulation time for simply passing through stations (without functions and item attributes)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Interface Files}
\label{\detokenize{source/Interface_files/interface:interface-files}}\label{\detokenize{source/Interface_files/interface:interface}}\label{\detokenize{source/Interface_files/interface::doc}}
\sphinxAtStartPar
This chapter defines the structure of the two input interface files and the options available to the user for mapping
production processes. First, the elements of the JSON file describing the simulation objects are presented, followed by
the different function types of the py file.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/data_file:data-file}]{\sphinxcrossref{\DUrole{std,std-ref}{Data file}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{Function file}}}}

\end{itemize}

\sphinxAtStartPar
A further section describes the possible distributions used to initialize the attributes of simulation objects when they
are created.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:attr-values}]{\sphinxcrossref{\DUrole{std,std-ref}{Attribute values}}}}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A subset of the exceptions listed in the following sections will only be thrown when the inspect method is called.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsection{Production structure}
\label{\detokenize{source/Interface_files/data_file:production-structure}}\label{\detokenize{source/Interface_files/data_file:data-file}}\label{\detokenize{source/Interface_files/data_file::doc}}
\sphinxAtStartPar
Each production process is defined in its own JSON file. This file contains a top\sphinxhyphen{}level object with two required
attributes and one optional one. The structure of these attributes is described as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/data_file:order}]{\sphinxcrossref{\DUrole{std,std-ref}{Order}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/data_file:station}]{\sphinxcrossref{\DUrole{std,std-ref}{Station}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/data_file:factory2}]{\sphinxcrossref{\DUrole{std,std-ref}{Factory}}}}

\end{enumerate}


\bigskip\hrule\bigskip



\subsubsection{Order}
\label{\detokenize{source/Interface_files/data_file:order}}\label{\detokenize{source/Interface_files/data_file:id1}}
\sphinxAtStartPar
The Order attribute is an attribute of the top\sphinxhyphen{}level production process object and is of the type JSON Array. This array
contains JSON objects and defines an order that combines all of the information about a particular order. The attributes
of an order are differentiated into predefined and user\sphinxhyphen{}defined attributes. Any attribute whose name is not predefined
is considered a user\sphinxhyphen{}defined attribute. In this section, all predefined attributes are described in detail. The possible
characteristics of the user\sphinxhyphen{}defined attributes are described in a separate section. {\hyperref[\detokenize{source/Interface_files/attribute_values:attr-values}]{\sphinxcrossref{\DUrole{std,std-ref}{section}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Only the individual parameters are described below. In  {\hyperref[\detokenize{source/Examples/example01:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{example 01}}}} , a concrete example of this file is
given.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{name}}

\sphinxAtStartPar
The name is a required parameter of the data type String. It will later serve as an identifier for the different
jobs and should therefore be unique.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
no
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
/
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
If name was not set
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadType
&
\sphinxAtStartPar
If name isn ot a string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Since the suffix ‘\_x’ references identical assembly workpieces that are assembled in different process steps (see
{\hyperref[\detokenize{source/Interface_files/function_file:process-function}]{\sphinxcrossref{\DUrole{std,std-ref}{process function}}}}), the name cannot have such a suffix.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{priority}}

\sphinxAtStartPar
The priority is an optional integer parameter. It determines the processing order when multiple jobs request the same
scarce resource. If no priorities are set, then the program determines its order. A small value corresponds to a high
priority. If several orders do not use the same station, then the priorities have no meaning.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
10
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If priority is not an integer
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
If priority is less than one
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{storage}}

\sphinxAtStartPar
The storage is an optional integer parameter that specifies the storage capacity of the final store of an order. The
storage is a piece value.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Even though this parameter is optional, it should always be set if there is no perfect understanding of the process;
otherwise, situations may occur where an increasing number of item objects are stored in stores over the simulation
time. This would lead to memory overload and slow the simulation speed.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
infinite
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If capacity is not an integer
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
If capacity is less than one
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{source/Interface_files/data_file:source}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{source}}

\sphinxAtStartPar
The source is a required parameter of type string. The function from the {\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{production functions}}}}
file with the corresponding name is assigned to this order.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
/
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
UndefinedFunction
&
\sphinxAtStartPar
Function is not defined in the passed file
\\
\hline&
\sphinxAtStartPar
InvalidFunction
&
\sphinxAtStartPar
Function is not a generator function
\\
\hline&
\sphinxAtStartPar
InvalidSignature
&
\sphinxAtStartPar
Function does not have exactly two arguments
\\
\hline&
\sphinxAtStartPar
InvalidYield
&
\sphinxAtStartPar
Yielded object is not of type int or Timeout
\\
\hline&
\sphinxAtStartPar
InfiniteLoop
&
\sphinxAtStartPar
Source contains an infinite loop
\\
\hline&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
No source was defined
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadSignature
&
\sphinxAtStartPar
The signature is not (‘env’, ‘factory’)
\\
\hline&
\sphinxAtStartPar
BadYield
&
\sphinxAtStartPar
Source does not yield a timeout event
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{source/Interface_files/data_file:sink}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sink}}

\sphinxAtStartPar
The sink is an optional parameter of type string. This order is assigned the function from the
{\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{production functions}}}} file with the corresponding name. If workpieces of this order represent
assembly workpieces concerning another process, then the default sink will never be active. If this is not the case,
then it removes all workpieces from the final store without a time delay.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
infinite source
&
\sphinxAtStartPar
If item is not part of an assembly process
\\
\hline&
\sphinxAtStartPar
no source
&
\sphinxAtStartPar
If item is part of an assembly process
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
UndefinedFunction
&
\sphinxAtStartPar
Function is not defined in the passed file
\\
\hline&
\sphinxAtStartPar
InvalidFunction
&
\sphinxAtStartPar
Function is not a generator function
\\
\hline&
\sphinxAtStartPar
InvalidSignature
&
\sphinxAtStartPar
Function does not have exactly two arguments
\\
\hline&
\sphinxAtStartPar
InvalidYield
&
\sphinxAtStartPar
Yielded object is not of type int or Timeout
\\
\hline&
\sphinxAtStartPar
InfiniteLoop
&
\sphinxAtStartPar
Source contains an infinite loop
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadSignature
&
\sphinxAtStartPar
The signature is not (‘env’, ‘factory’)
\\
\hline&
\sphinxAtStartPar
BadYield
&
\sphinxAtStartPar
Source does not yield a timeout event
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{station}}

\sphinxAtStartPar
The station attribute is an optional attribute of type Array. This array contains strings that represent the names of
stations in the order in which items of this order visit them. The default value is an empty array, which means that the
source places new workpieces directly into the final store (reflecting, for example, the retrieval of external assembly
workpieces).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
{[}{]}
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
UndefinedObject
&
\sphinxAtStartPar
No station is defined with this name
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The program does not throw exceptions related to the array’s length because the size of this array is considered a
reference for the length of the other arrays.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{source/Interface_files/data_file:function}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{function}}

\sphinxAtStartPar
The function attribute is an optional attribute of type array. It contains strings that correspond to the names of
functions defined in the  {\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{process functions}}}} file. The index position determines the connection of
process functions to stations.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
{[}{]}
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
UndefinedFunction
&
\sphinxAtStartPar
No function with this name is defined
\\
\hline&
\sphinxAtStartPar
InvalidSignature
&
\sphinxAtStartPar
Function does not have four arguments
\\
\hline&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
Number of functions does not match the number of stations
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadSignature
&
\sphinxAtStartPar
At least one argument has a bad name
\\
\hline&
\sphinxAtStartPar
BadYield
&
\sphinxAtStartPar
Function does not yield a simpy.Timeout object
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\phantomsection\label{\detokenize{source/Interface_files/data_file:demand}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{demand}}

\sphinxAtStartPar
The demand parameter is an optional parameter of type array. The index position of the entries connects them to the
stations from the station’s list. If a station performs an assembly or a pure machining process in a given process step,
then it determines the structure of the entries of the array. In machining at the station with index position i, the
i\sphinxhyphen{}th element of the demand array is an integer that determines the demand of this station. Another array of integers
at the corresponding index position in an assembly, which determines the number of individual assembly pieces. The
{\hyperref[\detokenize{source/Interface_files/data_file:component1}]{\sphinxcrossref{\DUrole{std,std-ref}{component}}}} attribute specifies which workpieces are used in an assembly. The default value is a list
with only 1s and the length of the station list. Thus, the default case represents a pure line production.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
{[}1, 1, .., 1{]}
&
\sphinxAtStartPar
Only possible if there is no assembly
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
Number of elements does not match the number of stations
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If the list contains different objects than int or list of int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
Integer element in the list is not greater than zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
No exceptions are thrown if the inner structure does not fit around the attribute component because demand serves as
a reference to avoid redundant error messages.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{source/Interface_files/data_file:component1}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{component}}

\sphinxAtStartPar
The component attribute is an optional attribute of type array. The inner structure of this array corresponds to that
of the demand {\hyperref[\detokenize{source/Interface_files/data_file:demand}]{\sphinxcrossref{\DUrole{std,std-ref}{demand attribute}}}}. In the case of pure processing, there is an empty array at the
corresponding index position. In assembly, the inner array contains strings that correspond to the names of orders and
specify what type the assembly workpieces should be. The default value is an array with only empty arrays; thus, as with
the attribute demand, a pure line production is represented.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
{[}{[}{]}, {[}{]}, .., {[}{]}{]}
&
\sphinxAtStartPar
Only possible if there is no assembly
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
Number of elements does not match the number of stations or the length of the assembly process list does not
match the length of the assembly demand list
\\
\hline&
\sphinxAtStartPar
UndefinedObject
&
\sphinxAtStartPar
No item is defined with this name
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
Structure does not correspond to the demand structure
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
List contains object with a type other than ‘list’
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Station}
\label{\detokenize{source/Interface_files/data_file:station}}\label{\detokenize{source/Interface_files/data_file:id2}}
\sphinxAtStartPar
The station attribute is an attribute of the top\sphinxhyphen{}level production process object and is of the type JSON Array. This
array contains JSON objects that define a station that combines all of the information about a particular station. The
attributes of a station are differentiated into predefined and user\sphinxhyphen{}defined attributes. Every attribute whose name is
not predefined is considered a user\sphinxhyphen{}defined attribute. This section describes all predefined attributes in detail. The
possible characteristics of the user\sphinxhyphen{}defined attributes are described in a separate {\hyperref[\detokenize{source/Interface_files/attribute_values:attr-values}]{\sphinxcrossref{\DUrole{std,std-ref}{section}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Only the individual parameters are described below. In {\hyperref[\detokenize{source/Examples/example01:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{example 01}}}}, a concrete example of this file is
given.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{name}}

\sphinxAtStartPar
The name is a required parameter of type string. It is used later to identify station objects and therefore must be
unique.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
no
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
/
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
MissingParameter
&
\sphinxAtStartPar
If name was not set
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadType
&
\sphinxAtStartPar
If name is not a string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{capacity}}

\sphinxAtStartPar
The capacity is an optional integer parameter. It specifies the number of machines that the corresponding station has
and thus serves to map the production type of the shop floor production. The default value is one and it thus rather
represents a line production process. If a station has several machines, then one of the free machines is selected
randomly before machining at this station.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
1
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If capacity is not an integer
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
If capacity is less than one
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{storage}}

\sphinxAtStartPar
The storage attribute is optional and of type integer. It describes the storage capacity of the buffer storage of a
station. This attribute is a unit value.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Even though this parameter is optional, it should always be set if a perfect understanding of the process does not
exist; otherwise, an arbitrary accumulation of numerous objects could occur in the memory, which would slow the
simulation arbitrarily.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
infinite
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If storage is not an integer
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
If storage is less than one
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{measurement}}

\sphinxAtStartPar
The measurement attribute is optional and of type Boolean. If a station is a measurement or quality control station
where the item attributes are not changed, then this attribute should be set to ‘true’. The effect is that workpieces
will not be tracked at this station, regardless of whether they are tracked at other stations.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
false
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
If measurement is not a Boolean
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Factory}
\label{\detokenize{source/Interface_files/data_file:factory}}\label{\detokenize{source/Interface_files/data_file:factory2}}
\sphinxAtStartPar
The factory attribute is an optional attribute of the top\sphinxhyphen{}level production process object. Unlike the order and station
attributes, it is not an array but rather a single JSON object. This object contains all global attributes that any
process function, sink, source, and global function can retrieve. All of these attributes are user\sphinxhyphen{}definable. The rules
that apply to these attributes are described in the {\hyperref[\detokenize{source/Interface_files/attribute_values:attr-values}]{\sphinxcrossref{\DUrole{std,std-ref}{‘Attribute values’}}}} section. In addition, the
factory object has a predefined attribute, which is described below.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{function}}

\sphinxAtStartPar
The function is an optional attribute of type array. This array contains strings that correspond to the global functions
from the functions file. The global variables are controlled from these functions, whose structure is described in more
detail in the {\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{‘function file}}}} section.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{14}|\X{3}{14}|\X{8}{14}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Optional
&
\sphinxAtStartPar
yes
&\\
\hline
\sphinxAtStartPar
Default value
&
\sphinxAtStartPar
{[}{]}
&\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
UndefinedFunction
&
\sphinxAtStartPar
No function with this name is defined
\\
\hline&
\sphinxAtStartPar
InvalidFunction
&
\sphinxAtStartPar
Function is not a generator function
\\
\hline&
\sphinxAtStartPar
InvalidSignature
&
\sphinxAtStartPar
Function does not have exactly two argument
\\
\hline&
\sphinxAtStartPar
InvalidYield
&
\sphinxAtStartPar
Function yielded an object that is not of type
\\
\hline
\sphinxAtStartPar
Warnings
&
\sphinxAtStartPar
BadSignature
&
\sphinxAtStartPar
Parameters are not called ‘env’ and ‘factory’
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Production functions}
\label{\detokenize{source/Interface_files/function_file:production-functions}}\label{\detokenize{source/Interface_files/function_file:function-file}}\label{\detokenize{source/Interface_files/function_file::doc}}
\sphinxAtStartPar
The functions input file is a Python script in which the user defines all of the functions used in the process input
file. The functions must be defined in the global scope and can be classified as follows
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/function_file:process-function}]{\sphinxcrossref{\DUrole{std,std-ref}{Process function}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/function_file:source-sink}]{\sphinxcrossref{\DUrole{std,std-ref}{Source and sink}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/function_file:global-function}]{\sphinxcrossref{\DUrole{std,std-ref}{Global function}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/function_file:distribution}]{\sphinxcrossref{\DUrole{std,std-ref}{Distribution}}}}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The following subsections describe only the structure and functionality. The use of these functions is presented in
chapter 3 ({\hyperref[\detokenize{source/Examples/examples:examples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}}).
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsubsection{Process function}
\label{\detokenize{source/Interface_files/function_file:process-function}}\label{\detokenize{source/Interface_files/function_file:id1}}
\sphinxAtStartPar
All process functions referenced in the orders under the ‘function’ attribute must be defined in the function input
file. The process functions are used to represent machining or assembly operations, and each of these functions has four
arguments: \sphinxstyleemphasis{env}, \sphinxstyleemphasis{item}, \sphinxstyleemphasis{machine}, and \sphinxstyleemphasis{factory}. The following paragraphs explain what these arguments are used for:

\sphinxAtStartPar
\sphinxstylestrong{env}

\sphinxAtStartPar
The argument env points to the reference of the simulation environment of the simulation kernel. This reference can be
used to access the current simulation time via the attribute now to make the behavior of the process function dependent
on the simulation time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{current\PYGZus{}sim\PYGZus{}time}\PYG{p}{:} \PYG{n+nb}{float} \PYG{o}{=} \PYG{n}{env}\PYG{o}{.}\PYG{n}{now}
\end{sphinxVerbatim}

\sphinxAtStartPar
In addition, this reference is used to set the current process to the \sphinxstyleemphasis{active without control} state. For this purpose,
a \sphinxstyleemphasis{simpy.Timeout} event is yielded through \sphinxstyleemphasis{env}. The duration of the release of control is controlled by a time
interval passed in the process. The machine is blocked for this time such that, for example, maintenance or processing
times can be mapped.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Using a random delay}
\PYG{n}{delay}\PYG{p}{:} \PYG{n+nb}{float} \PYG{o}{=} \PYG{n}{normalvariate}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Delays must be positive}
\PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{delay}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Any number of timeout events can be yielded in a process function, whereas returns are only used to manage the
control flow if necessary.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{item}

\sphinxAtStartPar
Through the argument \sphinxstyleemphasis{item}, all references to workpieces involved in the process can be accessed. The following table
displays which information is available.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{6}{28}|\X{3}{28}|\X{3}{28}|\X{16}{28}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Read
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Write
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Access
\\
\hline
\sphinxAtStartPar
attributes
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{item.attr\_1} (e.g.)
\\
\hline
\sphinxAtStartPar
id
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{\sphinxhyphen{}}
&
\sphinxAtStartPar
\sphinxtitleref{item.item\_id}
\\
\hline
\sphinxAtStartPar
name
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{\sphinxhyphen{}}
&
\sphinxAtStartPar
\sphinxtitleref{item.name}
\\
\hline
\sphinxAtStartPar
reject
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{item.reject}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The following figure illustrates what the item access structures look like when the workpieces are nested or the demand
of the process is greater than one.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.320\linewidth]{{assembling_structure}.png}\hspace*{\fill}}

\sphinxAtStartPar
The item attribute always references the main workpiece of a process \textendash{} itemA in this case. The figure shows that two
workpieces of type itemC were assembled into itemA. Whenever the quantity is greater than one, the references are stored
in lists. The access to an attribute (e.g., \sphinxstyleemphasis{attr\_1}) of the first of the two itemC items looks as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{item}\PYG{o}{.}\PYG{n}{itemC}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{attr\PYGZus{}1}
\end{sphinxVerbatim}

\sphinxAtStartPar
If two (or more) workpieces of the same type were assembled in different assembly steps (see \sphinxstyleemphasis{itemB}), then access would
be made in a special way. Starting from the second workpiece, the references are supplemented by the prefix ‘\_’ and a
continuing suffix. Thus, identical workpieces from different process steps can be differentiated. Assuming the middle
itemB was mounted second, access from its attributes (e.g., \sphinxstyleemphasis{attr\_2}) would be as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} accessing, the first assembled itemB}
\PYG{n}{item}\PYG{o}{.}\PYG{n}{itemB}\PYG{o}{.}\PYG{n}{attr\PYGZus{}2}

\PYG{c+c1}{\PYGZsh{} accessing, the second assembled itemB}
\PYG{n}{item}\PYG{o}{.}\PYG{n}{\PYGZus{}itemB2}\PYG{o}{.}\PYG{n}{attr\PYGZus{}2}
\end{sphinxVerbatim}

\sphinxAtStartPar
This structure can be nested as far as required. Thus, access to attributes (e.g., \sphinxstyleemphasis{attr\_3}) of itemD is through
\sphinxstyleemphasis{itemB}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{item}\PYG{o}{.}\PYG{n}{itemB}\PYG{o}{.}\PYG{n}{itemD}\PYG{o}{.}\PYG{n}{attr\PYGZus{}3}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{machine}

\sphinxAtStartPar
The \sphinxstyleemphasis{machine} argument can be used to reference the attributes of the machine on which the machining takes place. In
addition, each machine of a station has its own number.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{6}{30}|\X{3}{30}|\X{3}{30}|\X{18}{30}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Read
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Write
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Access
\\
\hline
\sphinxAtStartPar
attributes
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{machine.attr\_1} (e.g.)
\\
\hline
\sphinxAtStartPar
machine nr
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{\sphinxhyphen{}}
&
\sphinxAtStartPar
\sphinxtitleref{machine.nr}
\\
\hline
\sphinxAtStartPar
name
&
\sphinxAtStartPar
\sphinxtitleref{+}
&
\sphinxAtStartPar
\sphinxtitleref{\sphinxhyphen{}}
&
\sphinxAtStartPar
\sphinxtitleref{machine.name}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Since there are no nested structures as with the items, access is always via \sphinxstyleemphasis{machine.attr\_name}.

\sphinxAtStartPar
\sphinxstylestrong{factory}

\sphinxAtStartPar
All global attributes can be reached through the \sphinxstyleemphasis{factory} reference. These can also be assigned new values from process
functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{factory}\PYG{o}{.}\PYG{n}{global\PYGZus{}attr}
\end{sphinxVerbatim}

\sphinxAtStartPar
However, the behavior of the global attributes is not so controllable since, particularly with stochastic processes, how
often or when a process function is called is not known. Therefore, the global attributes should only be set based on
{\hyperref[\detokenize{source/Interface_files/function_file:global-function}]{\sphinxcrossref{\DUrole{std,std-ref}{global functions}}}}.


\bigskip\hrule\bigskip



\subsubsection{Source and Sink}
\label{\detokenize{source/Interface_files/function_file:source-and-sink}}\label{\detokenize{source/Interface_files/function_file:source-sink}}
\sphinxAtStartPar
Each job has exactly one source and one sink. Their tasks are to create workpieces in the production process and to
remove them after they have passed through the process. By matching the behavior of the source and sink, a push or pull
material flow can be configured in the production system.

\sphinxAtStartPar
A source or sink is defined as a function in the global scope in the function input file and must match the values of
the \sphinxstyleemphasis{sink} and \sphinxstyleemphasis{source} attributes of the orders. Such a function has exactly two arguments: \sphinxstyleemphasis{env} and \sphinxstyleemphasis{factory}. As
described for the {\hyperref[\detokenize{source/Interface_files/function_file:process-function}]{\sphinxcrossref{\DUrole{std,std-ref}{processes}}}}, through these arguments the user can access the current
simulation time and generate timeout events, and access to global attributes is provided.

\sphinxAtStartPar
The following figure illustrates the logic of the source and sink functions. These functions can yield any number of
objects of type int or \sphinxstyleemphasis{simpy.Timeout}. As soon as an \sphinxstyleemphasis{int} value is yielded, the iteration over the source or sink
(generator) is aborted, and the yielded value corresponds to the number of workpieces that the source/sink
generates/removes. If no int value is yielded, then the iteration stops after the last yield and starts again.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.390\linewidth]{{source_logic}.png}\hspace*{\fill}}

\sphinxAtStartPar
If no sink is defined, then the default sink removes all workpieces from the corresponding end storage without any time
delay (if no assembly workpieces are taken from this store for another order). If workpieces are always to be ready for
production, an infinite source can be defined. For this purpose, the storage of the corresponding buffer memory must be
and an \sphinxstyleemphasis{int} value from the source must be yielded as the first value. Thus, the source always fills up the storage
without a time offset and stops when it is full.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define an infinite source}
\PYG{k}{def} \PYG{n+nf}{infinite\PYGZus{}source}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{yield} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
{\hyperref[\detokenize{source/Examples/example03:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{Example 03}}}} gives a concrete example of the interaction of an infinite source and sink with a demand
curve over time.


\bigskip\hrule\bigskip



\subsubsection{Global function}
\label{\detokenize{source/Interface_files/function_file:global-function}}\label{\detokenize{source/Interface_files/function_file:id2}}
\sphinxAtStartPar
Global functions are specified via the \sphinxstyleemphasis{functions} attribute of the \sphinxstyleemphasis{factory} object and defined in the global scope of
the function input file. The task of the global functions is to control the behavior of the global attributes. Global
functions get two arguments: \sphinxstyleemphasis{env} and \sphinxstyleemphasis{factory}. Through env, as already shown with the
{\hyperref[\detokenize{source/Interface_files/function_file:process-function}]{\sphinxcrossref{\DUrole{std,std-ref}{process functions}}}}, \sphinxstyleemphasis{timeout} events can be generated and the simulation time can be queried,
while factory is used to obtain access to the global attributes to assign new values to them depending on the time. The
following figure presents the required structure of a global function schematically:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.380\linewidth]{{global_func_logic}.png}\hspace*{\fill}}

\sphinxAtStartPar
First, the global attributes are assigned updated values; arbitrarily nested structures can be used. Subsequently, at
least one \sphinxstyleemphasis{timeout} event must be yielded. This is because the global functions are executed parallel to the simulation in
an infinite loop; without a \sphinxstyleemphasis{timeout} event, the simulated time would not progress.

\sphinxAtStartPar
Example {\hyperref[\detokenize{source/Examples/example02:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{02}}}} demonstrates how to assign a time profile to global variables. Example {\hyperref[\detokenize{source/Examples/example03:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{03}}}} illustrates
how global functions can be used to influence the behavior of the production system.


\bigskip\hrule\bigskip



\subsubsection{Distribution}
\label{\detokenize{source/Interface_files/function_file:distribution}}\label{\detokenize{source/Interface_files/function_file:id3}}
\sphinxAtStartPar
The user\sphinxhyphen{}defined distributions that can be assigned to the attributes of the simulation objects are also defined in the
global scope of the function input file. For content reasons, the structure of these functions is introduced together
with the  {\hyperref[\detokenize{source/Interface_files/attribute_values:user-defined}]{\sphinxcrossref{\DUrole{std,std-ref}{attribute distributions}}}}.


\subsection{Attribute values}
\label{\detokenize{source/Interface_files/attribute_values:attribute-values}}\label{\detokenize{source/Interface_files/attribute_values:attr-values}}\label{\detokenize{source/Interface_files/attribute_values::doc}}
\sphinxAtStartPar
This section presents the possible distributions that can be assigned to the attributes of the simulation objects. A
distribution is defined in the form of a list. The first element of the list is always a string of length 1, which
serves as an identifier for the different distributions. The remaining attributes define the specific distribution
parameters.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Distribution
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Identifier
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameters
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:user-defined}]{\sphinxcrossref{\DUrole{std,std-ref}{User defined}}}}
&
\sphinxAtStartPar
/
&
\sphinxAtStartPar
/
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:fix}]{\sphinxcrossref{\DUrole{std,std-ref}{Fix}}}}
&
\sphinxAtStartPar
f
&
\sphinxAtStartPar
{[}“f”, \(\nu\) {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{Binary}}}}
&
\sphinxAtStartPar
b
&
\sphinxAtStartPar
{[}“b”, \sphinxstyleemphasis{p} {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:binomial}]{\sphinxcrossref{\DUrole{std,std-ref}{Binomial}}}}
&
\sphinxAtStartPar
i
&
\sphinxAtStartPar
{[}“i”, \sphinxstyleemphasis{n} , \sphinxstyleemphasis{p} {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:normal}]{\sphinxcrossref{\DUrole{std,std-ref}{Normal}}}}
&
\sphinxAtStartPar
n
&
\sphinxAtStartPar
{[}“n”, \(\mu\) , \(\sigma\) {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:uniform}]{\sphinxcrossref{\DUrole{std,std-ref}{Uniform}}}}
&
\sphinxAtStartPar
u
&
\sphinxAtStartPar
{[}“u”, \sphinxstyleemphasis{a} , \sphinxstyleemphasis{b} {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:poisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson}}}}
&
\sphinxAtStartPar
p
&
\sphinxAtStartPar
{[}“p”, \(\lambda\) {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:exponential}]{\sphinxcrossref{\DUrole{std,std-ref}{Exponential}}}}
&
\sphinxAtStartPar
e
&
\sphinxAtStartPar
{[}“e”, \(\beta\) {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:lognormal}]{\sphinxcrossref{\DUrole{std,std-ref}{Lognormal}}}}
&
\sphinxAtStartPar
l
&
\sphinxAtStartPar
{[}“l”, \(\mu\) , \(\sigma\) {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:chisquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Chisquare}}}}
&
\sphinxAtStartPar
c
&
\sphinxAtStartPar
{[}“c”, \sphinxstyleemphasis{n} {]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Interface_files/attribute_values:standard-t}]{\sphinxcrossref{\DUrole{std,std-ref}{Standard\sphinxhyphen{}t}}}}
&
\sphinxAtStartPar
t
&
\sphinxAtStartPar
{[}“t”, \sphinxstyleemphasis{n} {]}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{User defined}
\label{\detokenize{source/Interface_files/attribute_values:user-defined}}\label{\detokenize{source/Interface_files/attribute_values:id1}}
\sphinxAtStartPar
If the desired distribution is not predefined, then the user can define custom distribution functions. Such a function
is defined in the global scope of the function {\hyperref[\detokenize{source/Interface_files/function_file:function-file}]{\sphinxcrossref{\DUrole{std,std-ref}{input file}}}}. The function’s name later serves as an
identifier and thus must have length 1 and not intersect with the predefined ones. Since the return value of such a
function is assigned to the attributes, the return type must be int or float. However, the defined function can have any
number of arguments of any type. In the distribution list, the arguments of this function are then passed in the same
order.

\sphinxAtStartPar
Example:

\sphinxAtStartPar
The task is to define the following distribution function, which is not predefined, and then assign it to an attribute.
\begin{equation*}
\begin{split}P(X=x) = \left\{\begin{array}{ll} \frac{1}{2} & ;x=0.9 \\
                     \frac{1}{4} & ;x=1.8 \\
         \frac{1}{8} & ;x=2.9 \\
         \frac{1}{8} & ;x=6 \\
         0 & ;else\\
         \end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
It is possible to define a function that uses the values shown. Alternatively, a general function is defined that can be
used to map other arbitrary discrete distributions. For this purpose, x is used as a free identifier and choice from
numpy.random as distribution. The attributes of the function x are two lists that contain the probabilities and discrete
values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{choice}

\PYG{k}{def} \PYG{n+nf}{x}\PYG{p}{(}\PYG{n}{values}\PYG{p}{,} \PYG{n}{probabilities}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Union}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{]}\PYG{p}{:}
   \PYG{k}{return} \PYG{n}{choice}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{values}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{n}{probabilities}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, this distribution needs to be added to the attribute.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}x\PYGZdq{}}\PYG{p}{,[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{1.8}\PYG{p}{,}\PYG{l+m+mf}{2.9}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{],[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.25}\PYG{p}{,}\PYG{l+m+mf}{0.125}\PYG{p}{,}\PYG{l+m+mf}{0.125}\PYG{p}{]]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_ud}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
User\sphinxhyphen{}defined distributions are not checked by the inspector.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsubsection{Fixed}
\label{\detokenize{source/Interface_files/attribute_values:fixed}}\label{\detokenize{source/Interface_files/attribute_values:fix}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{f} indicates a fixed attribute value. The second parameter of the list specifies the fixed value
\(\nu\) that the attribute takes. Like all other attributes, the types \sphinxstyleemphasis{int} and \sphinxstyleemphasis{float} are possible. Distribution:

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}P(x=\nu)=1\ ,\hspace{0.2cm} \nu\in\mathbb{R}\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}prob\PYGZus{}of\PYGZus{}failure\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}f\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{4.34}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_f}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
f
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\(\nu\)
&
\sphinxAtStartPar
Value
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\(\nu\) is not of type int or float
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Binary}
\label{\detokenize{source/Interface_files/attribute_values:binary}}\label{\detokenize{source/Interface_files/attribute_values:id2}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{b} indicates a binary attribute value. The second element of the list is the probability \sphinxstyleemphasis{p} that
the attribute takes the value 1. \sphinxstyleemphasis{B(k,p)} indicates the probability that an attribute takes the values \sphinxstyleemphasis{k}, given
probability \sphinxstyleemphasis{p}.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}B(k,p) = \left\{\begin{array}{ll} p^k(1-p)^{1-k} & ;k\in\lbrace0,1\rbrace \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} p\in\lbrack0,1\rbrack\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}b\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_b}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
b
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{p}
&
\sphinxAtStartPar
Success probability
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\sphinxstyleemphasis{p} is not of type int or float
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\sphinxstyleemphasis{p} is not between 0.0 and 1.0
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Binomial}
\label{\detokenize{source/Interface_files/attribute_values:binomial}}\label{\detokenize{source/Interface_files/attribute_values:id3}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{i} indicates a binomial attribute value. The second list element is the number of trails \sphinxstyleemphasis{n}, while the
third is the success probability \sphinxstyleemphasis{p}. \sphinxstyleemphasis{B(k,p)} indicates the probability that an attribute takes the values \sphinxstyleemphasis{k}, given
probability \sphinxstyleemphasis{p} and the number of trails \sphinxstyleemphasis{n}.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}B(k,n,p) = \left\{\begin{array}{ll}\binom{n}{k} p^k(1-p)^{1-k} & ;k\in\lbrace0,..,n\rbrace \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} p\in\lbrack0,1\rbrack\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}i\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mf}{0.4}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_i}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
i
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{n}
&
\sphinxAtStartPar
Number of trails
\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{p}
&
\sphinxAtStartPar
Success probability for each trail
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is not of type int
\\
\hline&&
\sphinxAtStartPar
\sphinxstyleemphasis{p} is not of type int or float
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is not greater than zero
\\
\hline&&
\sphinxAtStartPar
\sphinxstyleemphasis{p} is not between 0.0 and 1.0
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Normal}
\label{\detokenize{source/Interface_files/attribute_values:normal}}\label{\detokenize{source/Interface_files/attribute_values:id4}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{n} indicates a normally distributed attribute. The second list entry corresponds to the mean
\(\mu\) and the third to the standard deviation \(\sigma\).

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\ ;\hspace{0.2cm} x,\mu\in\mathbb{R},\ \sigma\ge 0\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_n}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
n
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\(\mu\)
&
\sphinxAtStartPar
Mean
\\
\hline&
\sphinxAtStartPar
\(\sigma\)
&
\sphinxAtStartPar
Standard deviation
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 3
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\(\mu\) or \(\sigma\) is not of type int or float
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\(\sigma\) is smaller than zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Uniform}
\label{\detokenize{source/Interface_files/attribute_values:uniform}}\label{\detokenize{source/Interface_files/attribute_values:id5}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{u} indicates a uniform distributed attribute. The second list parameter \sphinxstyleemphasis{a} is the lower limit, while
the third \sphinxstyleemphasis{b} sets the upper interval limit. The limits can be integers or floating\sphinxhyphen{}point numbers.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p(x) = \left\{\begin{array}{ll}\frac{1}{b-a} & ;x\in\lbrack b,..,a) \\
                     0 & ;else\end{array}\right.\ ;\hspace{0.2cm} a,b\in\mathbb{R},\ b>a\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}u\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{2.34}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_u}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
u
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{a}
&
\sphinxAtStartPar
lower bound
\\
\hline&
\sphinxAtStartPar
\sphinxstyleemphasis{a}
&
\sphinxAtStartPar
upper bound
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 3
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\sphinxstyleemphasis{a} or \sphinxstyleemphasis{b} is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\sphinxstyleemphasis{a} is greater or equal \sphinxstyleemphasis{b}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Poisson}
\label{\detokenize{source/Interface_files/attribute_values:poisson}}\label{\detokenize{source/Interface_files/attribute_values:id6}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{p} indicates a Poisson\sphinxhyphen{}distributed attribute. The second list entry determines the rate \(\lambda\),
which must be type float or int and greater than or equal to zero. \(P(k,\lambda)\)lambda\textasciigrave{}.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}P(k,\lambda) = \left\{\begin{array}{ll}\frac{\lambda^ke^{-\lambda}}{k!} & ;k\in\mathbb{N}_{\ge0} \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} \lambda>0\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}p\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_p}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
p
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\(\lambda\)
&
\sphinxAtStartPar
Rate
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\(\lambda\) is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\(\lambda\) is less than zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Exponential}
\label{\detokenize{source/Interface_files/attribute_values:exponential}}\label{\detokenize{source/Interface_files/attribute_values:id7}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{e} indicates an exponential distributed attribute. The second list element is the scale \(\beta\),
which can be a positive floating\sphinxhyphen{}point number.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p(x) = \left\{\begin{array}{ll} \frac{1}{\beta} e^{-\frac{x}{\beta}} & ;x \ge 0 \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} \beta\in\mathbb{R}_{>0}\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}e\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_e}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
e
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\(\beta\)
&
\sphinxAtStartPar
Scale
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\(\beta\) is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\(\beta\) is less or equal to zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Often the exponential function is also defined by the rate \(\lambda=\frac{1}{\beta}\), instead of the scale
\(\beta\). For more information see
\sphinxhref{https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html}{numpy.random.exponential}.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsubsection{Lognormal}
\label{\detokenize{source/Interface_files/attribute_values:lognormal}}\label{\detokenize{source/Interface_files/attribute_values:id8}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{l} indicates a lognormal distributed attribute. The second list entry corresponds to the mean
\(\mu\) and the third to the standard deviation \(\sigma\); \(\mu\) and \(\sigma\) must be of type int
or float, while \(\sigma\) must also be greater than or equal to zero.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p(x) = \left\{\begin{array}{ll} \frac{1}{\sigma x \sqrt{2\pi}}e^{-\frac{(\ln{x}-\mu)^{2}}{2\sigma^{2}}} & ;x > 0 \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} \mu\in\mathbb{R},\ \sigma\in\mathbb{R}_{>0}\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}l\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_l}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
l
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\(\mu\)
&
\sphinxAtStartPar
Mean
\\
\hline&
\sphinxAtStartPar
\(\sigma\)
&
\sphinxAtStartPar
Standard deviation
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 3
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\(\mu\) or \(\sigma\) is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\(\sigma\) is less than zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Chisquare}
\label{\detokenize{source/Interface_files/attribute_values:chisquare}}\label{\detokenize{source/Interface_files/attribute_values:id9}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{c} indicates a chi\sphinxhyphen{}square distributed attribute. The second list entry determines the degrees of freedom
\sphinxstyleemphasis{n}, which must be a positive floating\sphinxhyphen{}point or integer.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p_{n}(x) = \left\{\begin{array}{ll} \frac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}} & ;x > 0 \\
                     0 & ;else\end{array}\right.\ ,\hspace{0.2cm} x\in\mathbb{R},\ n\in\mathbb{R}_{>0}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Gamma(x)=\int^{-\infty}_{0}t^{x-1}e^{-t}dt\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}c\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_c}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
c
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{n}
&
\sphinxAtStartPar
Degrees of freedom
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is less than or equal to zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\bigskip\hrule\bigskip



\subsubsection{Student\sphinxhyphen{}t}
\label{\detokenize{source/Interface_files/attribute_values:student-t}}\label{\detokenize{source/Interface_files/attribute_values:standard-t}}
\sphinxAtStartPar
The identifier \sphinxstyleemphasis{t} indicates a student\sphinxhyphen{}t distributed attribute. The second list entry determines the degrees of freedom
\sphinxstyleemphasis{n}, which must be a positive floating\sphinxhyphen{}point or integer.

\sphinxAtStartPar
Distribution:
\begin{equation*}
\begin{split}p_n(x)=\frac{\Gamma(\frac{n+1}{2})}{\Gamma(\frac{n}{2})\sqrt{n\pi}}(1+\frac{x^2}{n})^{-\frac{n+1}{2}}\ ,\hspace{0.2cm} x\in\mathbb{R},\ n\in\mathbb{R}_{>0}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Gamma(x)=\int^{-\infty}_{0}t^{x-1}e^{-t}dt\end{split}
\end{equation*}
\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZdq{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}t\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{distribution_t}.png}\hspace*{\fill}}

\sphinxAtStartPar
Overview:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{3}{13}|\X{2}{13}|\X{8}{13}|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
Identifier
&
\sphinxAtStartPar
t
&\\
\hline
\sphinxAtStartPar
Additional parameter
&
\sphinxAtStartPar
\sphinxstyleemphasis{n}
&
\sphinxAtStartPar
Degrees of freedom
\\
\hline
\sphinxAtStartPar
Exceptions
&
\sphinxAtStartPar
InvalidFormat
&
\sphinxAtStartPar
List does not have length 2
\\
\hline&
\sphinxAtStartPar
InvalidType
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is not of type float or int
\\
\hline&
\sphinxAtStartPar
InvalidValue
&
\sphinxAtStartPar
\sphinxstyleemphasis{n} is less than or equal to zero
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Simulation output}
\label{\detokenize{source/Interface_files/output_file:simulation-output}}\label{\detokenize{source/Interface_files/output_file:output-file}}\label{\detokenize{source/Interface_files/output_file::doc}}
\sphinxAtStartPar
Two predefined output formats are available: csv and hdf5. In both formats the output is provided in tabular form. In
the case of csv, a file is created for each simulation object (station, order, factory) whose data should be saved. In
the case of hdf5, a single file is created that contains a group for each simulation object.

\sphinxAtStartPar
The {\hyperref[\detokenize{source/Interface_files/output_file:general-structure}]{\sphinxcrossref{\DUrole{std,std-ref}{general structure}}}} of the output files is described first, followed by the specifics for
the individual simulation objects ({\hyperref[\detokenize{source/Interface_files/output_file:output-station}]{\sphinxcrossref{\DUrole{std,std-ref}{station}}}}, {\hyperref[\detokenize{source/Interface_files/output_file:output-order}]{\sphinxcrossref{\DUrole{std,std-ref}{order}}}},
{\hyperref[\detokenize{source/Interface_files/output_file:output-factory}]{\sphinxcrossref{\DUrole{std,std-ref}{factory}}}}).


\bigskip\hrule\bigskip



\subsubsection{General structure}
\label{\detokenize{source/Interface_files/output_file:general-structure}}\label{\detokenize{source/Interface_files/output_file:id1}}
\sphinxAtStartPar
The output files are in tabular form, to which rows are added during simulation. The first columns contain all
user\sphinxhyphen{}defined attributes and the following columns contain some object (station, order, factory) specific information.

\sphinxAtStartPar
For the tables of stations and orders it applies that for each processing that is carried out on a machine of a
station, the corresponding table of the order and the station are extended by a row that containing the relevant
information regarding the time point at which the respective interaction is completed. Whereas the factory table is
extended by one row after each call of a global function.


\bigskip\hrule\bigskip



\subsubsection{Output station}
\label{\detokenize{source/Interface_files/output_file:output-station}}\label{\detokenize{source/Interface_files/output_file:id2}}
\sphinxAtStartPar
The first columns contain the respective user\sphinxhyphen{}defined values of the station attributes. While the last two columns
contain the machine number and the current simulation time.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{output_file_station}.png}\hspace*{\fill}}

\sphinxAtStartPar
The \sphinxstylestrong{machine number} corresponds to the index of the machine of a station. The index starts for each station with
zero and can be read during the simulation to implement machine specific behavior.

\sphinxAtStartPar
The simulation \sphinxstylestrong{time} corresponds to the time point in which a machining or assembly operation was completed
successfully at a machine.


\bigskip\hrule\bigskip



\subsubsection{Output order}
\label{\detokenize{source/Interface_files/output_file:output-order}}\label{\detokenize{source/Interface_files/output_file:id3}}
\sphinxAtStartPar
Similar to the output files of the other simulation objects, the first columns contain the values of the user\sphinxhyphen{}defined
attributes. The following columns contain the item ID, assembly comp, station ID and simulation time.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{output_file_order}.png}\hspace*{\fill}}

\sphinxAtStartPar
The \sphinxstylestrong{item ID} is a unique integer ID increasing throughout the simulation.

\sphinxAtStartPar
The column \sphinxstylestrong{comp} is only included if items of the order are assembled to items of another order in the process. The
column contains the unique item ID of the item to which the item referred to in the column is assembled.  If the item
is not assembled in the first stage, the value nan will appear in the rows created before this assembly.

\sphinxAtStartPar
The \sphinxstylestrong{station ID} is the ID of the station at which the corresponding row was added. The station ID is assigned
automatically and corresponds to the index position (starting with 0) of the station in the input JSON file.
Additionally, there is the index \sphinxstyleemphasis{\sphinxhyphen{}1}. This index corresponds to the rows that are added directly after the creation of
new items in the source.

\sphinxAtStartPar
The simulation \sphinxstylestrong{time} corresponds to the time point in which a item was processed successfully at a machine.


\bigskip\hrule\bigskip



\subsubsection{Output factory}
\label{\detokenize{source/Interface_files/output_file:output-factory}}\label{\detokenize{source/Interface_files/output_file:id4}}
\sphinxAtStartPar
The first columns contain the values of the user\sphinxhyphen{}defined global attributes. While the last column contains the
simulation time at which the attribute values of the attributes were recorded.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{output_file_factory}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Different from the stations and the orders, a row is created after each execution of a global function. If there are
no global functions, no rows are added. In this case an \sphinxstyleemphasis{empty} global function can be created, which only yields
timeouts in required time steps.
\end{sphinxadmonition}


\section{Defining processes}
\label{\detokenize{source/Defining_processes/defining_processes:first}}\label{\detokenize{source/Defining_processes/defining_processes:defining-processes}}\label{\detokenize{source/Defining_processes/defining_processes:id1}}\label{\detokenize{source/Defining_processes/defining_processes::doc}}
\sphinxAtStartPar
In general, the structure of the process is described in a JSON file and the actions in a python\sphinxhyphen{}script (see
{\hyperref[\detokenize{source/Interface_files/interface:interface}]{\sphinxcrossref{\DUrole{std,std-ref}{Interface Files}}}}). Since the initial setup of these files is time consuming and discourages the user from using ProdSim
for the first time, a web application for defining new processes is offered. When the structure of a process has been
completely defined and individual parameters need to be changed between simulation runs, it is easier to change them
directly in the corresponding JSON file instead of using the application.

\sphinxAtStartPar
The application is intended as an optional extension of Base\sphinxhyphen{}ProdSim and can be easily removed from the project during
individual ongoing development of ProdSim.

\sphinxAtStartPar
The following describes how the given fictitious production process can be modeled.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_ex_process}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The application is not part of the actual project and is still under development. Please report bugs and
malfunctions, as well as useful enhancement suggestions.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsection{Start the application}
\label{\detokenize{source/Defining_processes/defining_processes:start-the-application}}\label{\detokenize{source/Defining_processes/defining_processes:dp-call-dp}}
\sphinxAtStartPar
To start the application the method \sphinxcode{\sphinxupquote{define\_process}} has to be called on a simulation environment.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{prodsim} \PYG{k+kn}{import} \PYG{n}{Environment}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Create simulation environment}
    \PYG{n}{env} \PYG{o}{=} \PYG{n}{Environment}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Start the application}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{define\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Copying the link into a browser (or clicking on the link, depending on your IDE) will open the following window.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1.000\linewidth]{{define_process_start}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsection{Create and change order}
\label{\detokenize{source/Defining_processes/defining_processes:create-and-change-order}}\label{\detokenize{source/Defining_processes/defining_processes:dp-order}}
\sphinxAtStartPar
In order to define a new process, it is recommended to start with creating all used orders and to use them as a base for
further operations. New orders can be created using the \sphinxtitleref{add order} button. The following dialog opens.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_add_order}.png}\hspace*{\fill}}

\sphinxAtStartPar
Thereby only the fields \sphinxtitleref{order name} and \sphinxtitleref{source name} must be filled with unique strings. All other fields are
optional and will be filled with the default values (see: {\hyperref[\detokenize{source/Interface_files/data_file:data-file}]{\sphinxcrossref{\DUrole{std,std-ref}{interface files}}}}) if not filled.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The name of an order, as well as the number of stations, cannot be changed afterwards.
\end{sphinxadmonition}

\sphinxAtStartPar
The number of stations corresponds to the number of process steps that the items of the corresponding order pass
through. For example, order a contains three stations because the second station is visited twice ({\hyperref[\detokenize{source/Defining_processes/defining_processes:first}]{\sphinxcrossref{\DUrole{std,std-ref}{see}}}}).

\sphinxAtStartPar
Once all orders have been defined, the graph is initially empty, because changes to the graph are only displayed when
the \sphinxtitleref{refresh graph} button is clicked (internally, these changes are also saved without clicking the button). Clicking
the refresh button results in the following graph:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1.000\linewidth]{{define_process_orders}.png}\hspace*{\fill}}

\sphinxAtStartPar
To change individual properties of an order or to assign user\sphinxhyphen{}defined attributes to the items of this order, click on
the end storage (triangle) of this order in the graph and perform the needed changes in the opening dialog.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_change_order}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsection{Change station}
\label{\detokenize{source/Defining_processes/defining_processes:change-station}}\label{\detokenize{source/Defining_processes/defining_processes:dp-station}}
\sphinxAtStartPar
Similar to the orders, single stations can be clicked to change their properties. The opening dialog consists of three
areas. In the upper area, the core properties (name, capacity, storage, measurement) of the station can be changed. In
the second area, for each order in which the station is involved, the function that will be performed and whether
machining or assembly will be performed can be specified. In the third area, user\sphinxhyphen{}defined attributes may be assigned to
the station.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_change_station}.png}\hspace*{\fill}}

\sphinxAtStartPar
For example, components of orders a and c are to be assembled at the third station of order b ({\hyperref[\detokenize{source/Defining_processes/defining_processes:first}]{\sphinxcrossref{\DUrole{std,std-ref}{see}}}}). This
can be defined in the dialog as follows:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_assembly}.png}\hspace*{\fill}}

\sphinxAtStartPar
In addition, the second station in job a is to be used twice and job b and c should share a station. This can be
realized with the button \sphinxtitleref{combine stations}. By clicking on the button the following dialog opens:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_combine_stations}.png}\hspace*{\fill}}

\sphinxAtStartPar
The names of the two stations that will be combined into a single station can be entered here. The station in the
second field will be deleted and replaced by the station in the first field. After carrying out the modifications
described above, the graph can be refreshed by clicking refresh graph. The changes made ( assemblies and combined use
of stations) appear in the graph.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1.000\linewidth]{{describe_process_update_graph}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsection{Edit factory}
\label{\detokenize{source/Defining_processes/defining_processes:edit-factory}}\label{\detokenize{source/Defining_processes/defining_processes:dp-factory}}
\sphinxAtStartPar
Finally, the properties of the \sphinxtitleref{factory} can be set. By clicking the button \sphinxtitleref{edit factory} the following dialog opens.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{decribe_process_factory}.png}\hspace*{\fill}}

\sphinxAtStartPar
All global functions and global attributes can be entered here.


\bigskip\hrule\bigskip



\subsection{Create files}
\label{\detokenize{source/Defining_processes/defining_processes:create-files}}\label{\detokenize{source/Defining_processes/defining_processes:dp-files}}
\sphinxAtStartPar
Once the entire process has been defined as required, the corresponding output files must be created and saved. To do
this, the following dialog can be opened by clicking the \sphinxtitleref{create files} button.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.600\linewidth]{{define_process_create_files}.png}\hspace*{\fill}}

\sphinxAtStartPar
The first field contains the name of the project and the second field the path (relative or absolute) to the directory
where the output files will be saved. Two files will be created. A JSON file containing the entire structure of the
process and a python\sphinxhyphen{}script containing all necessary functions (sources and sinks, process models and global functions).
These functions are empty and must be filled with the desired content before the simulation.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
No data is cached during the definition of a process, so closing the window deletes all data.
\end{sphinxadmonition}


\section{Examples}
\label{\detokenize{source/Examples/examples:examples}}\label{\detokenize{source/Examples/examples:id1}}\label{\detokenize{source/Examples/examples::doc}}
\sphinxAtStartPar
In this chapter, the concrete use of the simulation program is presented through the use of examples. The aim of these
examples is not to represent realistic contexts. Instead, they represent as many aspects as possible and are
chronologically oriented to the later workflow. In addition, the examples are independent of each other in order to look
up individual functionalities selectively. The following table serves as a guide:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Focus
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Examples/example01:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{01}}}}
&
\sphinxAtStartPar
Defining a production layout

\sphinxAtStartPar
Inspecting input files

\sphinxAtStartPar
Visualizing input files
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Examples/example02:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{02}}}}
&
\sphinxAtStartPar
Defining machining functions

\sphinxAtStartPar
Using global functions
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Examples/example03:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{03}}}}
&
\sphinxAtStartPar
Defining an infinite source

\sphinxAtStartPar
Using global attributes

\sphinxAtStartPar
Using a pull process principle
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{source/Examples/example04:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{04}}}}
&
\sphinxAtStartPar
Accessing assembly workpiece attributes

\sphinxAtStartPar
Rejecting items

\sphinxAtStartPar
Transforming and filtering output data
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The examples presented hereafter are provided as executable examples in the following folder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{n}{ProdSim}\PYG{o}{/}\PYG{n}{examples}\PYG{o}{/}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsection{Example 01: Gearbox}
\label{\detokenize{source/Examples/example01:example-01-gearbox}}\label{\detokenize{source/Examples/example01:id1}}\label{\detokenize{source/Examples/example01::doc}}
\sphinxAtStartPar
In this example, all steps are run through that should be conducted before each new simulation study. The focus is on
the actual procedure and less on the process itself. Therefore, the process functions, sources, sinks, and attributes of
the simulation objects are not filled with concrete content. Examples  {\hyperref[\detokenize{source/Examples/example02:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{02}}}}, {\hyperref[\detokenize{source/Examples/example03:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{03}}}}, and
{\hyperref[\detokenize{source/Examples/example04:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{04}}}} focus on the concrete modeling of process functions and sources.


\bigskip\hrule\bigskip



\subsubsection{Process description}
\label{\detokenize{source/Examples/example01:process-description}}
\sphinxAtStartPar
Before any simulation study, the production process should first be formally described. For assembly processes, the use
of a product tree is recommended to represent the product structure. The hierarchical relationship of the components
with each other and the individual quantities are displayed. As shown with the
{\hyperref[\detokenize{source/Interface_files/function_file:process-function}]{\sphinxcrossref{\DUrole{std,std-ref}{process functions}}}},this simplifies the later access to the workpiece attributes starting from
the process functions. The following figure presents such a product tree using the example of a gearbox:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.400\linewidth]{{product_tree_gearbox}.png}\hspace*{\fill}}

\sphinxAtStartPar
In addition, the production process should be represented in the form of a network. All product components’ final stores
(triangles) and all processing and assembly stations (circles) are drawn in. Then, all production processes are drawn in
by directed edges between the stations. In addition, for assembly processes, the edges for the assembly workpieces from
the final stores to the assembly stations are inserted.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.700\linewidth]{{product_process_gearbox}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsubsection{Define orders}
\label{\detokenize{source/Examples/example01:define-orders}}\label{\detokenize{source/Examples/example01:id2}}
\sphinxAtStartPar
After describing the production process, the input files are defined. First, the orders should be specified in the JSON
file. For this purpose, an order is created for each element from the product tree. Even if the elements gearbox and
gear\_shaft are not physical products but rather only namespaces for the union of elementary components, then these are
also defined as orders. Thus, attributes can be assigned to them later.

\sphinxAtStartPar
The following procedure is recommended when defining an order:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Set general information (\sphinxstyleemphasis{name}, \sphinxstyleemphasis{priority}, \sphinxstyleemphasis{storage}, \sphinxstyleemphasis{source}, and \sphinxstyleemphasis{sink})

\item {} 
\sphinxAtStartPar
Describe the process of the order (\sphinxstyleemphasis{station}, \sphinxstyleemphasis{function}, \sphinxstyleemphasis{demand}, and \sphinxstyleemphasis{component})

\item {} 
\sphinxAtStartPar
Add custom attributes

\end{enumerate}

\sphinxAtStartPar
The corresponding orders are presented as follows. The storage capacity is limited to 10 for each order to avoid
unintentionally overfilling the computer memory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
  \PYG{n+nt}{\PYGZdq{}order\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}gearbox\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}1\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}station\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gb\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}quality\PYGZus{}check\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gb\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}quality\PYGZus{}check\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}demand\PYGZdq{}}\PYG{p}{:} \PYG{p}{[[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{],}\PYG{l+m+mi}{2}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}component\PYGZdq{}}\PYG{p}{:} \PYG{p}{[[}\PYG{l+s+s2}{\PYGZdq{}housing\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}screw\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}gear\PYGZus{}shaft\PYGZdq{}}\PYG{p}{],[]]}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}housing\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}1\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}screw\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}1\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}gear\PYGZus{}shaft\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}1\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}station\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gs\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gs\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}demand\PYGZdq{}}\PYG{p}{:} \PYG{p}{[[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]],}
      \PYG{n+nt}{\PYGZdq{}component\PYGZdq{}}\PYG{p}{:} \PYG{p}{[[}\PYG{l+s+s2}{\PYGZdq{}gear\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}shaft\PYGZdq{}}\PYG{p}{]]}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}gear\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}station\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}heat\PYGZus{}treatment\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}heating\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}demand\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}shaft\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}source\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}source\PYGZus{}2\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}station\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}lathe\PYGZdq{}}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}turning\PYGZdq{}}\PYG{p}{]}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Define stations}
\label{\detokenize{source/Examples/example01:define-stations}}\label{\detokenize{source/Examples/example01:define-station}}
\sphinxAtStartPar
Next, the stations can be defined. For this purpose, a station object is created for each station in the production
process. Since stations do not have as many properties as orders, the following procedure is recommended:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Set general information (\sphinxstyleemphasis{name}, \sphinxstyleemphasis{storage}, \sphinxstyleemphasis{capacity}, and \sphinxstyleemphasis{measurement})

\item {} 
\sphinxAtStartPar
Add custom attributes

\end{enumerate}

\sphinxAtStartPar
Here, the capacities are also limited in order not to overfill the computer memory. In addition, the station
\sphinxstyleemphasis{quality\_check} is a pure measuring station where no attributes are changed. Therefore, \sphinxstyleemphasis{measurement} is set to \sphinxstyleemphasis{true}
for this station.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}station\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}lathe\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}heat\PYGZus{}treatment\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gs\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}assemble\PYGZus{}gb\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}
    \PYG{p}{\PYGZcb{},}
    \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}name\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}quality\PYGZus{}check\PYGZdq{}}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}storage\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10}\PYG{p}{,}
      \PYG{n+nt}{\PYGZdq{}measurement\PYGZdq{}}\PYG{p}{:} \PYG{k+kc}{true}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Define factory}
\label{\detokenize{source/Examples/example01:define-factory}}\label{\detokenize{source/Examples/example01:id3}}
\sphinxAtStartPar
Finally, the global attributes and global functions must be defined. For this purpose, all attributes and global
functions are assigned to the \sphinxstyleemphasis{factory} object.

\sphinxAtStartPar
As an example, two global attributes and one global function are defined as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{n+nt}{\PYGZdq{}factory\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
      \PYG{n+nt}{\PYGZdq{}glob\PYGZus{}attr\PYGZus{}1\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}f\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}glob\PYGZus{}attr\PYGZus{}2\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{],}
      \PYG{n+nt}{\PYGZdq{}function\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}glob\PYGZus{}func\PYGZus{}1\PYGZdq{}}\PYG{p}{]}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Define functions}
\label{\detokenize{source/Examples/example01:define-functions}}\label{\detokenize{source/Examples/example01:id4}}
\sphinxAtStartPar
After the JSON file is set up, the Python script must be created. In this script, all previously used functions
(sources, sinks, process functions, global functions, and distributions) are defined. As this focuses on the procedure,
these functions are not assigned any content here. Therefore, examples  {\hyperref[\detokenize{source/Examples/example02:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{02}}}},
{\hyperref[\detokenize{source/Examples/example03:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{03}}}}, and {\hyperref[\detokenize{source/Examples/example04:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{04}}}} should be viewed.


\bigskip\hrule\bigskip



\subsubsection{Inspect}
\label{\detokenize{source/Examples/example01:inspect}}\label{\detokenize{source/Examples/example01:id5}}
\sphinxAtStartPar
After both input files are fully defined, the \sphinxcode{\sphinxupquote{inspect()}} method can be called to identify errors that do not
terminate the program when reading the data. Before doing so, a simulation environment must be created and the
corresponding data read in.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{prodsim} \PYG{k+kn}{import} \PYG{n}{Environment}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Create simulation environment}
    \PYG{n}{env} \PYG{o}{=} \PYG{n}{Environment}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Read in the process data}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{read\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.data/process.json}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/function.py}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Inspect the process data}
    \PYG{n}{env}\PYG{o}{.}\PYG{n}{inspect}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the following example, two errors were deliberately introduced in the JSON file. First, the signature of the process
function \sphinxcode{\sphinxupquote{turning}} was changed, and the global function \sphinxcode{\sphinxupquote{global\_func\_1}} did not yield a timeout event. After calling
\sphinxcode{\sphinxupquote{inspect}}, the output was as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
progress station: [====================] 100\PYGZpc{}  quality\PYGZus{}check
progress order:   [====================] 100\PYGZpc{}  shaft
factory:          [====================] 100\PYGZpc{}  factory
WARNINGS\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Traceback (most recent call last):
  File \PYGZdq{}/Users/user/prodsim/inspector.py\PYGZdq{}, line 522, in \PYGZus{}\PYGZus{}inspect\PYGZus{}order
    warnings.warn(
        prodsim.exception.BadSignature: The signature of a process function should be (env, item, machine,
        factory), but in the function \PYGZsq{}turning\PYGZsq{} at least one argument has a different name.

EXCEPTIONS\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Traceback (most recent call last):
  File \PYGZdq{}/Users/user/prodsim/inspector.py\PYGZdq{}, line 575, in \PYGZus{}\PYGZus{}inspect\PYGZus{}factory
    raise prodsim.exception.InvalidFunction(
        prodsim.exception.InvalidFunction: The function \PYGZsq{}glob\PYGZus{}func\PYGZus{}1\PYGZsq{} from the
        function file is not a generator function. A global function must yield at least one timeout\PYGZhy{}event.

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Number of Warnings:    1
Number of Exceptions:  1
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Visualize}
\label{\detokenize{source/Examples/example01:visualize}}\label{\detokenize{source/Examples/example01:id6}}
\sphinxAtStartPar
Finally, the \sphinxcode{\sphinxupquote{visualize}} method can be called to check if the process was defined correctly.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Visualize the process data}
\PYG{n}{env}\PYG{o}{.}\PYG{n}{visualize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This call leads to the following output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Dash is running on http://127.0.0.1:8050/

 * Serving Flask app \PYGZsq{}ProdSim\PYGZus{}app\PYGZsq{} (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: on
\end{sphinxVerbatim}

\sphinxAtStartPar
By clicking on the link, a browser window opens that presents the interactive network graph.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.900\linewidth]{{screenshot_web_app}.png}\hspace*{\fill}}


\subsection{Example 02: Shaft}
\label{\detokenize{source/Examples/example02:example-02-shaft}}\label{\detokenize{source/Examples/example02:id1}}\label{\detokenize{source/Examples/example02::doc}}
\sphinxAtStartPar
The focus of this example is the modeling of global and process functions. First, the process displayed is briefly
outlined. Then, the individual functions are described in detail. Finally, the simulation output is used to validate the
considerations.


\bigskip\hrule\bigskip



\subsubsection{Process description}
\label{\detokenize{source/Examples/example02:process-description}}\label{\detokenize{source/Examples/example02:id2}}
\sphinxAtStartPar
Because the focus is on the functions, a simple process is deliberately used here. The process is a linear machining
line, which operates on a cycle time of one minute. Since the drilling process takes 2 minutes, the station uses two
machines to fulfill the cycle time. During this process, shafts are first drilled, turned, and then polished. The
purpose of the simulation study is to determine the course of the surface quality over time. Shafts are not rejected
during the process.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{shaft_process}.png}\hspace*{\fill}}

\sphinxAtStartPar
In addition, it is assumed that the process occurs in a factory with a temperature variation throughout the day, which
influences the polishing process.


\bigskip\hrule\bigskip



\subsubsection{Process function: drilling}
\label{\detokenize{source/Examples/example02:process-function-drilling}}\label{\detokenize{source/Examples/example02:drilling}}
\sphinxAtStartPar
First, the shafts are drilled. Each machine has a probability (0.15\% in this example) that the drill will break
(drill\_breakage). If this occurs, then the surface (surface) roughness will increase by an average of two units. In
addition, the machine used for the machining process is blocked for the duration of the machining (2 minutes) by
yielding a timeout event.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{drilling}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} If the drill breaks the surface roughness increases}
    \PYG{k}{if} \PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{drill\PYGZus{}breakage}\PYG{p}{:}
        \PYG{n}{item}\PYG{o}{.}\PYG{n}{surface} \PYG{o}{+}\PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{normalvariate}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Blocking the drilling machine for machining time}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Process function: turning}
\label{\detokenize{source/Examples/example02:process-function-turning}}\label{\detokenize{source/Examples/example02:turning}}
\sphinxAtStartPar
The lathe has wear that increases with each machining operation. Since the wear affects the surface quality, the lathe
must be maintained whenever the wear reaches a certain level (1 in this example). This maintenance reduces the wear
completely but blocks the machine for 10 minutes. The correlation (fictitious and for illustrative purposes only)
between surface quality and machine wear is as follows:
\begin{equation*}
\begin{split}\Delta surface = 1.5\cdot(wear)^{2} - 2\end{split}
\end{equation*}
\sphinxAtStartPar
The wear of the machine increases by 0.006 units on average for each machining operation, so an average of 167 machining
operations are possible between two rounds of maintenance.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{turning}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} If the wear exceeds a certain limit, the machine is maintained}
    \PYG{k}{if} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{wear} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{wear} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} The roughness achievable during machining depends on the wear of the machine}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{surface} \PYG{o}{+}\PYG{o}{=} \PYG{n}{machine}\PYG{o}{.}\PYG{n}{wear}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mf}{1.5}

    \PYG{c+c1}{\PYGZsh{} With each machining operation, the wear of the machine increases}
    \PYG{n}{machine}\PYG{o}{.}\PYG{n}{wear} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{normalvariate}\PYG{p}{(}\PYG{l+m+mf}{0.006}\PYG{p}{,}\PYG{l+m+mf}{0.00018}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Blocking the lathe for machining time}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Process function: polishing}
\label{\detokenize{source/Examples/example02:process-function-polishing}}\label{\detokenize{source/Examples/example02:polishing}}
\sphinxAtStartPar
The polishing process can reduce roughness. If the temperature in the factory increases, then the polishing machine’s
potential to reduce the surface roughness decreases. The relationship between roughness and temperature is as follows:
\begin{equation*}
\begin{split}\Delta surface = - (8 - temperature * 0.3)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{polishing}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} The roughness will decrease the lower the temperature is.}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{surface} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}} \PYG{n}{factory}\PYG{o}{.}\PYG{n}{temperature} \PYG{o}{*} \PYG{l+m+mf}{0.3}

    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Global function: temperature}
\label{\detokenize{source/Examples/example02:global-function-temperature}}\label{\detokenize{source/Examples/example02:temperature}}
\sphinxAtStartPar
In the global function \sphinxstyleemphasis{temperature\_func}, the profile of the temperature is described. In the simulated time (3 days),
it is assumed that the temperature profile (black) in the following figure is given every day. The global temperature
should correspond to the approximated course (red).

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{temperature_profile}.png}\hspace*{\fill}}

\sphinxAtStartPar
The temperature values are stored in a dictionary (in the global scope) and assigned to the temperature in
\sphinxstyleemphasis{temperature\_func}. The simulated time is checked for equality in the function, which is only allowed here because the
time intervals in the timeout event are not random (otherwise a KeyError would occur).

\sphinxAtStartPar
This temperature profile is only intended to demonstrate the functionality. Of course, it is possible to define much
finer profiles when corresponding data sets are available or to add certain variations to the values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temp\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{240}\PYG{p}{:} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{480}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{:} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{960}\PYG{p}{:} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{1200}\PYG{p}{:} \PYG{l+m+mi}{20}\PYG{p}{\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{temperature\PYGZus{}func}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Determinate the current daytime}
    \PYG{n}{day\PYGZus{}time} \PYG{o}{=} \PYG{n}{env}\PYG{o}{.}\PYG{n}{now} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1440}

    \PYG{c+c1}{\PYGZsh{} Set the new Temperature}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{temperature} \PYG{o}{=} \PYG{n}{temp\PYGZus{}dict}\PYG{p}{[}\PYG{n}{day\PYGZus{}time}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Wait exactly 4 hours}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{240}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Start simulation}
\label{\detokenize{source/Examples/example02:start-simulation}}\label{\detokenize{source/Examples/example02:id3}}
\sphinxAtStartPar
This code shows how the simulation is started. The simulation time is 4320 since this is exactly 3 days in the unit of
minutes. Since only the surface quality is of interest for the analysis, only the shafts are tracked. In addition, the
column \sphinxstyleemphasis{item\_id} is removed during the export of the data (For demonstration purposes only).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{prodsim} \PYG{k+kn}{import} \PYG{n}{Environment}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

   \PYG{c+c1}{\PYGZsh{} Create simulation environment}
   \PYG{n}{env} \PYG{o}{=} \PYG{n}{Environemnt}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{\PYGZsh{} Read in the process files}
   \PYG{n}{env}\PYG{o}{.}\PYG{n}{real\PYGZus{}files}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/process.json}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/function.py}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

   \PYG{c+c1}{\PYGZsh{} Start the simulation}
   \PYG{n}{env}\PYG{o}{.}\PYG{n}{simulate}\PYG{p}{(}\PYG{n}{sim\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{4320}\PYG{p}{,} \PYG{n}{track\PYGZus{}components}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{shaft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{progress\PYGZus{}bar}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

   \PYG{c+c1}{\PYGZsh{} Export the simulation data}
   \PYG{n}{env}\PYG{o}{.}\PYG{n}{data\PYGZus{}to\PYGZus{}csv}\PYG{p}{(}\PYG{n}{path\PYGZus{}to\PYGZus{}wd}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./output/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{remove\PYGZus{}column}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{item\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{keep\PYGZus{}original}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Simulation output}
\label{\detokenize{source/Examples/example02:simulation-output}}\label{\detokenize{source/Examples/example02:output}}
\sphinxAtStartPar
The diagram below depicts the surface roughness that the shafts exhibit over the simulated time after processing at each
station.

\sphinxAtStartPar
The following aspects can be identified:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The six outliers visible in the three plots are caused by broken drills;

\item {} 
\sphinxAtStartPar
The zigzag shape that starts at the turning process step is caused by wear, which increases until maintenance before
abruptly decreasing;

\item {} 
\sphinxAtStartPar
The effect of temperature appears in the wave\sphinxhyphen{}like course (green). There are three cycles since exactly 3 days were
simulated.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{surface}.png}\hspace*{\fill}}

\sphinxAtStartPar
The interruptions in production due to maintenance work at the lathe cannot be recognized. The reason for this is the
line thickness of the plots. The raw output data reveals the points in time at which the process is not active. This
time difference does not correspond exactly to the 10 minutes since the buffer stores are first filled before the
process succumbs.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{shaft_csv}.png}\hspace*{\fill}}


\subsection{Example 03: Bolt}
\label{\detokenize{source/Examples/example03:example-03-bolt}}\label{\detokenize{source/Examples/example03:id1}}\label{\detokenize{source/Examples/example03::doc}}
\sphinxAtStartPar
The purpose of this example is twofold: first, it sets up a pull\sphinxhyphen{}controlled material flow in the production system
using the interaction between the source and the sink of an order, and second, it shows that global attributes can
control the material flow in the production system.


\bigskip\hrule\bigskip



\subsubsection{Process description}
\label{\detokenize{source/Examples/example03:process-description}}\label{\detokenize{source/Examples/example03:process-description1}}
\sphinxAtStartPar
To understand the interaction of source and sink more easily, a simple process was chosen. A forge station has five
forges, each of which produces six bolts per minute. These forges can be independently activated without start\sphinxhyphen{}up times.
The finished bolt storage can hold up to 5000 bolts.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{bolt_process}.png}\hspace*{\fill}}

\sphinxAtStartPar
This process runs 24 hours a day, and demand fluctuates throughout the day at unknown levels. The goal is to activate
the machines to ensure that demand can be met and productivity is adjusted to demand.


\bigskip\hrule\bigskip



\subsubsection{Source}
\label{\detokenize{source/Examples/example03:source}}\label{\detokenize{source/Examples/example03:source1}}
\sphinxAtStartPar
Since the production process is controlled from the sink, it is necessary to ensure that enough input material is always
available. An infinite source achieves this.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{infinite\PYGZus{}source}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{yield} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
An infinite source, where new input material is placed without delay, does not yield a \sphinxstyleemphasis{timeout} event. To enable a
simulation with an infinite source, two conditions must be fulfilled:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The capacity of the buffer storage that is to be filled must be limited; and

\item {} 
\sphinxAtStartPar
The buffer storage capacity must be at least the same as the demand of the process concerning the first process step.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Stores that are filled by an infinite source should not be filled by additional finite sources since the infinite
sources dominate them.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsubsection{Global function}
\label{\detokenize{source/Examples/example03:global-function}}\label{\detokenize{source/Examples/example03:global1}}
\sphinxAtStartPar
There are three global attributes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{number\_bolts}: The number of bolts in the final storage

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{active\_machines}: The number of currently active machines

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{max\_active\_machines}: The maximum allowed number of currently active machines

\end{enumerate}

\sphinxAtStartPar
Since the demand (fictitious) is unknown and the production capacity is to be dynamically controlled, the number of
bolts in the final storage is used as a control variable.
\begin{equation*}
\begin{split}max\_active\_machine = \left\{\begin{array}{ll} 5 & ; number\_bolts \in \lbrack0,1000) \\
                     4 & ; number\_bolts \in \lbrack1000,2000) \\
         3 & ; number\_bolts \in \lbrack2000,3000) \\
         2 & ; number\_bolts \in \lbrack3000,4000) \\
         1 & ; number\_bolts \in \lbrack4000,5000) \\
         0 & ; number\_bolts = 5000\\
         \end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
The idea is that when the demand increases, the number of bolts in the final storage decreases. Thus, the lower the
number of bolts, the higher the number of active machines must be, such that the production capacity adjusts itself with
a slight time delay to the subsequent demand without having to know the demand. To make this work, the maximum average
demand must be smaller than the maximal production capacity of 30  (6 * 5).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{control\PYGZus{}logic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1000}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2000}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3000}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4000}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{global\PYGZus{}control}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Set max\PYGZus{}active\PYGZus{}machines\PYGZus{}based on number\PYGZus{}bolts}
    \PYG{k}{for} \PYG{n}{quantity} \PYG{o+ow}{in} \PYG{n}{control\PYGZus{}logic}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{factory}\PYG{o}{.}\PYG{n}{number\PYGZus{}bolts} \PYG{o}{\PYGZlt{}} \PYG{n}{quantity}\PYG{p}{:}
            \PYG{n}{factory}\PYG{o}{.}\PYG{n}{max\PYGZus{}active\PYGZus{}machines} \PYG{o}{=} \PYG{n}{control\PYGZus{}logic}\PYG{p}{[}\PYG{n}{quantity}\PYG{p}{]}
            \PYG{k}{break}
        \PYG{n}{factory}\PYG{o}{.}\PYG{n}{max\PYGZus{}active\PYGZus{}machines} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{c+c1}{\PYGZsh{} Update every time step (minute)}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Process function: forging}
\label{\detokenize{source/Examples/example03:process-function-forging}}\label{\detokenize{source/Examples/example03:forging}}
\sphinxAtStartPar
As the focus is on the material flow, no attributes of the bolts are considered in this process function. Before the
forging starts, whether the maximum number of active machines has been reached is checked. Since the cycle time is 1
minute, this check is repeated every minute. If this check is passed, then the number of active machines is increased,
and the machine is blocked for the forging time. After the forging has finished, the global variable for storage filling
is updated, and the number of active machines is updated again.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{forging}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Check if production capacity is reached.}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{factory}\PYG{o}{.}\PYG{n}{active\PYGZus{}machines} \PYG{o}{\PYGZlt{}} \PYG{n}{factory}\PYG{o}{.}\PYG{n}{max\PYGZus{}active\PYGZus{}machines}\PYG{p}{:}
            \PYG{k}{break}
        \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Update currently active machines}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{active\PYGZus{}machines} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{c+c1}{\PYGZsh{} Block forge for forging time}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Update store quantity}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{number\PYGZus{}bolts} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{6}

    \PYG{c+c1}{\PYGZsh{} Update currently active machines}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{active\PYGZus{}machines} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Sink}
\label{\detokenize{source/Examples/example03:sink}}\label{\detokenize{source/Examples/example03:temperature1}}
\sphinxAtStartPar
It is assumed that the demand follows the given course (black) daily and undergoes certain variations. An approximation
is made by six partial intervals, which demonstrate a certain scatter (the 95\% interval is indicated).

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.470\linewidth]{{demand_profile}.png}\hspace*{\fill}}

\sphinxAtStartPar
In addition, a large demand occurs for approximately 250 bolts approximately every 4 hours, which is also subject to
variation. The following function presents the realization of such a source behavior. In addition, the current inventory
in the final storage of the bolts is updated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Defines the demand distribution over time}
\PYG{n}{time\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\PYG{n}{demand\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{20.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{1.7}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{bolt\PYGZus{}sink}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{demand} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{day\PYGZus{}time} \PYG{o}{=} \PYG{n}{env}\PYG{o}{.}\PYG{n}{now} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{1440}

    \PYG{c+c1}{\PYGZsh{} Determine the standard demand}
    \PYG{k}{for} \PYG{n}{index}\PYG{p}{,} \PYG{n}{time\PYGZus{}interval} \PYG{o+ow}{in} \PYG{n}{time\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{time\PYGZus{}interval}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{day\PYGZus{}time}\PYG{o}{/}\PYG{l+m+mi}{60} \PYG{o}{\PYGZlt{}} \PYG{n}{time\PYGZus{}interval}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{dis} \PYG{o}{=} \PYG{n}{demand\PYGZus{}dict}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}
            \PYG{n}{demand} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{normalvariate}\PYG{p}{(}\PYG{n}{dis}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dis}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
            \PYG{k}{break}

    \PYG{c+c1}{\PYGZsh{} Determining the additional demand}
    \PYG{k}{if} \PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.004}\PYG{p}{:}
        \PYG{n}{demand} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{normalvariate}\PYG{p}{(}\PYG{l+m+mi}{250}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Update number of bolts}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{number\PYGZus{}bolts} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{demand}

    \PYG{c+c1}{\PYGZsh{} Just for output plotting purpose}
    \PYG{n}{factory}\PYG{o}{.}\PYG{n}{current\PYGZus{}demand} \PYG{o}{=} \PYG{n}{demand}

    \PYG{k}{yield} \PYG{n}{demand}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Simulation output}
\label{\detokenize{source/Examples/example03:simulation-output}}\label{\detokenize{source/Examples/example03:output2}}
\sphinxAtStartPar
The following figure depicts the course of the number of bolts in the final store as well as the demand. The additional
demands have been removed from the plot, and a moving average has been used for the demand. Due to oscillation processes
at the beginning, the simulated days 2\textendash{}4 are shown.

\sphinxAtStartPar
The following aspects can be identified:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
At midday, the demand is approximately 20, so three to four forges must be active to meet the demand. Therefore, the
average inventory at midday is 2000 (see {\hyperref[\detokenize{source/Examples/example03:global1}]{\sphinxcrossref{\DUrole{std,std-ref}{global\_control}}}}). At night, the demand is approximately
eight, so only one to two forges are required.

\item {} 
\sphinxAtStartPar
If there is an additional demand in the steady\sphinxhyphen{}state (e.g., at Sim. time = 2400), then the inventory level decreases
abruptly. This increases the number of active machines such that the required stock is built up again.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{demand}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Of course, this mechanism does not represent an efficiency control. The point of this example is rather the use of
global quantities to limit machine activity. For example, the currently available electricity can also serve as a
limit for the machines.
\end{sphinxadmonition}


\subsection{Example 04: Toy figure}
\label{\detokenize{source/Examples/example04:example-04-toy-figure}}\label{\detokenize{source/Examples/example04:id1}}\label{\detokenize{source/Examples/example04::doc}}
\sphinxAtStartPar
In this example, the characteristics of accessing assembly workpiece attributes are demonstrated. In addition, the usage
of the workpiece attributes \sphinxstyleemphasis{reject} and \sphinxstyleemphasis{item\_id} is described. Finally, the output structure is presented along with how
the output can be transformed into the required format.


\bigskip\hrule\bigskip



\subsubsection{Process description}
\label{\detokenize{source/Examples/example04:process-description}}\label{\detokenize{source/Examples/example04:process-description2}}
\sphinxAtStartPar
The production of plastic toy figures serves as an example process. The following product tree describes the components,
their quantities, and the assembly relationships.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.450\linewidth]{{figure_tree}.png}\hspace*{\fill}}

\sphinxAtStartPar
The components \sphinxstyleemphasis{arm}, \sphinxstyleemphasis{hand}, \sphinxstyleemphasis{leg} and \sphinxstyleemphasis{head} are produced externally and do not have separate machining steps within
the process itself. The body component is injection\sphinxhyphen{}molded within the process. First, the components \sphinxstyleemphasis{arm} and \sphinxstyleemphasis{hand}
are assembled into the module \sphinxstyleemphasis{upper\_limb}. In the following assembly process, all components are assembled in a figure.
Finally, quality is checked and incorrect figures are rejected.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.620\linewidth]{{figure_process}.png}\hspace*{\fill}}

\sphinxAtStartPar
The components are connected using ball\sphinxhyphen{}and\sphinxhyphen{}socket joints. Each joint has a diameter. Based on the difference in
diameters, the tension that occurs in the joint is determined. For example:
\begin{equation*}
\begin{split}t_4 = t_4(d_4,d_3)\end{split}
\end{equation*}
\sphinxAtStartPar
The diameters of the joints are the attributes of the respective components, whereas the resulting tensions are
determined during assembly and are therefore attributes of the modules or the final product. Since the figure is
symmetrical, all \sphinxstyleemphasis{arms}, \sphinxstyleemphasis{hands}, and \sphinxstyleemphasis{legs} have the same attributes with individual characteristics.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{figure}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsubsection{Assemble function}
\label{\detokenize{source/Examples/example04:assemble-function}}\label{\detokenize{source/Examples/example04:assemble-func}}
\sphinxAtStartPar
This subsection describes the assembly function that is called at the station \sphinxstyleemphasis{assemble\_figure}. The argument item of
the function references the workpiece in whose process path the station from which the process function was called is
located (figure). This attribute can be used to access all assembled workpieces that are assembled before or at the
station under consideration. According to the following relationship, the tension is calculated and stored in attributes
t4 to t8 of the \sphinxstyleemphasis{figure} workpiece for each ball joint:
\begin{equation*}
\begin{split}t_i(d_i,d_j) = (d_j - d_i - 2)^3 + 20\end{split}
\end{equation*}
\sphinxAtStartPar
As an example, tension t4 is used to describe the access of the required diameters; t4 depends on d3 of the right \sphinxstyleemphasis{arm}
and on d4 of the body. Since item refers to figure, the module upper\_limb must be accessed first. Since there are two
upper\_limbs, one of the two must be selected. By definition, it is declared that the first element corresponds to the
right \sphinxstyleemphasis{upper\_limb}. Since d3 is an attribute of the arm, the \sphinxstyleemphasis{upper\_limb} must be used to access the \sphinxstyleemphasis{arm} and then d3.
This results in the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d3\PYGZus{}1} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{arm}\PYG{o}{.}\PYG{n}{d3}
\end{sphinxVerbatim}

\sphinxAtStartPar
The structure is similar for the diameter d4. First, \sphinxstyleemphasis{item} (or figure) must be used to refer to \sphinxstyleemphasis{body}. Since d4 is an
attribute of body, d4 can be accessed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d4} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d4}
\end{sphinxVerbatim}

\sphinxAtStartPar
The two stresses t2 have already been determined during the assembly of the component \sphinxstyleemphasis{upper\_limb}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{assemble\PYGZus{}figure}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Get the diameters of the assembled items}
    \PYG{n}{d3\PYGZus{}1} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{arm}\PYG{o}{.}\PYG{n}{d3}
    \PYG{n}{d3\PYGZus{}2} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{arm}\PYG{o}{.}\PYG{n}{d3}
    \PYG{n}{d9\PYGZus{}1} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{leg}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{d9}
    \PYG{n}{d9\PYGZus{}2} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{leg}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{d9}
    \PYG{n}{d10} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{head}\PYG{o}{.}\PYG{n}{d10}

    \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{,} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{d2} \PYG{o}{\PYGZhy{}} \PYG{n}{d1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{20}

    \PYG{c+c1}{\PYGZsh{} Calculate the tension}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{t4} \PYG{o}{=} \PYG{n}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d4}\PYG{p}{,} \PYG{n}{d3\PYGZus{}1}\PYG{p}{)}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{t5} \PYG{o}{=} \PYG{n}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d5}\PYG{p}{,} \PYG{n}{d9\PYGZus{}1}\PYG{p}{)}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{t6} \PYG{o}{=} \PYG{n}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d6}\PYG{p}{,} \PYG{n}{d9\PYGZus{}2}\PYG{p}{)}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{t7} \PYG{o}{=} \PYG{n}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d7}\PYG{p}{,} \PYG{n}{d3\PYGZus{}2}\PYG{p}{)}
    \PYG{n}{item}\PYG{o}{.}\PYG{n}{t8} \PYG{o}{=} \PYG{n}{get\PYGZus{}t}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{body}\PYG{o}{.}\PYG{n}{d8}\PYG{p}{,} \PYG{n}{d10}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Block the machine for the assembly time}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsubsection{Quality check}
\label{\detokenize{source/Examples/example04:quality-check}}\label{\detokenize{source/Examples/example04:id2}}
\sphinxAtStartPar
During quality control, all figures that do not fulfill the quality requirements are rejected. The criterion used here
is the tension, which must lie within a specified interval to be able to rotate the corresponding components against
each other. For each tension, a check is performed to ensure that it lies within the specified interval. If not, then
the \sphinxstyleemphasis{reject} attribute is set to \sphinxstyleemphasis{True}. Consequently, this item (including all assembled items) is removed from the
process and is not added to the following store.

\sphinxAtStartPar
In addition, the id of the figures is stored in the global attribute \sphinxstyleemphasis{rejected\_id} to identify them more easily. In the
{\hyperref[\detokenize{source/Examples/example04:identify-rejected}]{\sphinxcrossref{\DUrole{std,std-ref}{following}}}}, a method for identifying rejected items without global attributes is described.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{quality\PYGZus{}check}\PYG{p}{(}\PYG{n}{env}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{machine}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Limits for the tension}
    \PYG{n}{t\PYGZus{}min} \PYG{o}{=} \PYG{l+m+mf}{17.0}
    \PYG{n}{t\PYGZus{}max} \PYG{o}{=} \PYG{l+m+mf}{23.0}

    \PYG{k}{def} \PYG{n+nf}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{t\PYGZus{}min} \PYG{o+ow}{or} \PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{t\PYGZus{}max}\PYG{p}{:}
            \PYG{n}{item}\PYG{o}{.}\PYG{n}{reject} \PYG{o}{=} \PYG{k+kc}{True}
            \PYG{n}{factory}\PYG{o}{.}\PYG{n}{rejected\PYGZus{}id} \PYG{o}{=} \PYG{n}{item}\PYG{o}{.}\PYG{n}{item\PYGZus{}id}
            \PYG{k}{return} \PYG{k+kc}{True}
        \PYG{k}{return} \PYG{k+kc}{False}

    \PYG{c+c1}{\PYGZsh{} Reject items and update profiling attributes}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{t4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r4} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{t5}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r5} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{t6}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r6} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{t7}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r7} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{t8}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r8} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{t2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r2\PYGZus{}1} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}reject}\PYG{p}{(}\PYG{n}{item}\PYG{o}{.}\PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{t2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{machine}\PYG{o}{.}\PYG{n}{r2\PYGZus{}2} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{c+c1}{\PYGZsh{} Block quality machine}
    \PYG{k}{yield} \PYG{n}{env}\PYG{o}{.}\PYG{n}{timeout}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The diameters of the joints are distributed as follows:
\begin{equation*}
\begin{split}d_i \sim N(40,0.4)\ ,i\in\lbrace1,3,9,10\rbrace\end{split}
\end{equation*}\begin{equation*}
\begin{split}d_i \sim N(42,0.4)\ ,i\in\lbrace4,..,7\rbrace\end{split}
\end{equation*}
\sphinxAtStartPar
For \sphinxstyleemphasis{d8}, a normal distribution is also assumed, but the mean diameter continues to increase due to wear during the
injection. After 1500 injection processes, the mold is replaced so that the diameter starts again at 40. The following
figure visualizes the behavior on the basis of the number of rejects corresponding to the rejection reasons \sphinxstyleemphasis{r6}, \sphinxstyleemphasis{r7},
and \sphinxstyleemphasis{r8}.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.480\linewidth]{{rejection}.png}\hspace*{\fill}}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If no attributes are changed at a station (e.g., \sphinxstyleemphasis{quality\_check}), then setting the attribute \sphinxstyleemphasis{measurement} to true
is recommended because the workpiece attributes will not be tracked at this station. This reduces the data usage.
\end{sphinxadmonition}


\bigskip\hrule\bigskip



\subsubsection{Merge output data}
\label{\detokenize{source/Examples/example04:merge-output-data}}\label{\detokenize{source/Examples/example04:merge}}
\sphinxAtStartPar
As a standard, the simulation data for each simulation object (order, station, factory) is saved in its own file. The
following text describes how these files can be merged in order to collect all information (d1,..,d10,t2,t4,..,t8)
concerning a single figure for all figures in a time series. Data merging according to the underlying assembly structure
is performed via the columns \sphinxstyleemphasis{item\_id} and \sphinxstyleemphasis{comp}. Each order output whose workpieces represent assembly workpieces of
at least one other order contains the column \sphinxstyleemphasis{comp}, which contains the \sphinxstyleemphasis{item\_id} of the item for which the assembly
item is assembled.

\sphinxAtStartPar
The following cutout of the csv file \sphinxstyleemphasis{arm.csv} indicates that the arm with the \sphinxstyleemphasis{item\_id} 81 is mounted to an
\sphinxstyleemphasis{upper\_limb} item with the \sphinxstyleemphasis{item\_id} 86. Likewise, \sphinxstyleemphasis{arm} 84 is assembled to \sphinxstyleemphasis{upper\_limb} 87.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{arm_csv}.png}\hspace*{\fill}}

\sphinxAtStartPar
In the file \sphinxstyleemphasis{hand.csv}, there are the two arms (item\_ids: 82 and 85), which are mounted to the \sphinxstyleemphasis{upper\_limbs} with the
item\_ids 86 and 87.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{hand_csv}.png}\hspace*{\fill}}

\sphinxAtStartPar
Finally, in the file \sphinxstyleemphasis{upper\_limb.csv}, the two workpieces with item\_ids 86 and 87 can be found. They are mounted on a
\sphinxstyleemphasis{figure} with the \sphinxstyleemphasis{item\_id} 77.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.800\linewidth]{{upper_limb_csv}.png}\hspace*{\fill}}

\sphinxAtStartPar
Based on the textually described context, the assembly structures can be automatically tracked. The following figure
provides an overview of the required steps.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First, the csv files must be filtered so that only the rows containing items at the last station (or at the station
where the current assembly structure is to be traced) are left

\item {} 
\sphinxAtStartPar
All columns that are not required are removed. Only the attribute columns are kept in files representing \sphinxstyleemphasis{sub}
components, while the \sphinxstyleemphasis{comp} column is chosen as the index. In files belonging to \sphinxstyleemphasis{main} items, the \sphinxstyleemphasis{item\_id} is used
as the index, and all columns except the \sphinxstyleemphasis{comp} and attribute columns are deleted.

\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{main} file is connected to the \sphinxstyleemphasis{sub} file (any number of sub files can be used) via the index (the concat method
from the pandas library is recommended).

\item {} 
\sphinxAtStartPar
If the \sphinxstyleemphasis{main} item is assembled further, the \sphinxstyleemphasis{comp} column must subsequently be selected as the index to connect the
new file again.

\end{enumerate}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.900\linewidth]{{merge}.png}\hspace*{\fill}}

\sphinxAtStartPar
A particular detail must be taken into account. If the demand is greater than one, then the \sphinxstyleemphasis{comp} column contains the
\sphinxstyleemphasis{item\_id} of the \sphinxstyleemphasis{main} item multiple times (e.g., \sphinxstyleemphasis{upper\_limb.csv} \sphinxhyphen{} \sphinxstyleemphasis{item\_id}: 77). The following figure demonstrates
how this case is handled. The file is split off (e.g., with the groupby method from the pandas library) using the \sphinxstyleemphasis{comp}
column. Thus, the attributes are numbered to be able to differentiate them later. This ensures that the index set \sphinxstyleemphasis{comp}
is unique and can be used to merge the files.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.900\linewidth]{{demand_greater_one}.png}\hspace*{\fill}}

\sphinxAtStartPar
The following code block shows how to switch a csv file to state \sphinxstyleemphasis{1} from the first figure. The \sphinxstyleemphasis{get\_df} method already
considers the case of demands greater than one. Thus, the partial data sets are returned in a list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}df}\PYG{p}{(}\PYG{n}{name}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,} \PYG{n}{num\PYGZus{}main\PYGZus{}args}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{sub}\PYG{p}{:} \PYG{n+nb}{bool} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{amount}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{index\PYGZus{}col}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{item\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{station\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{k}{if} \PYG{n}{sub}\PYG{p}{:}
        \PYG{n}{index\PYGZus{}col}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{comp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{station\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{item\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} set \PYGZsq{}index\PYGZus{}col\PYGZsq{} as row index, and remove the column \PYGZsq{}time\PYGZsq{} for all assemble objects by usecols (+3)}
    \PYG{n}{iter\PYGZus{}csv} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{path} \PYG{o}{+} \PYG{n}{name} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{usecols}\PYG{o}{=}\PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}
        \PYG{n}{num\PYGZus{}main\PYGZus{}args} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{iterator}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{chunksize}\PYG{o}{=}\PYG{l+m+mi}{10\PYGZus{}000}\PYG{p}{,} \PYG{n}{index\PYGZus{}col}\PYG{o}{=}\PYG{n}{index\PYGZus{}col}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} build DataFrame and remove the columns \PYGZsq{}labels\PYGZsq{}}
    \PYG{n}{temp\PYGZus{}df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{chunk}\PYG{p}{[}\PYG{n}{chunk}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{station\PYGZus{}id}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{station\PYGZus{}id}\PYG{p}{]} \PYG{k}{for} \PYG{n}{chunk} \PYG{o+ow}{in} \PYG{n}{iter\PYGZus{}csv}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{drop}\PYG{p}{(}\PYG{n}{labels}\PYG{o}{=}\PYG{n}{labels}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} if there are multiple objects split the dataframe an return them as a list}
    \PYG{k}{if} \PYG{n}{amount} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{temp\PYGZus{}df}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{temp\PYGZus{}df}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{comp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{nth}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add\PYGZus{}suffix}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{amount}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The files created in this manner must be nested by hand according to the assembly structure. The following code block
presents steps 2 and 3 for the final assembly step of a figure. Since the \sphinxstyleemphasis{figure} is the final assembly layer, the
\sphinxstyleemphasis{comp} column does not exist in this file and cannot be set as the index. The used DataFrame \sphinxstyleemphasis{upper\_limb} is previously
generated according to the same logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figure} \PYG{o}{=} \PYG{n}{get\PYGZus{}df}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{sub}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{head} \PYG{o}{=} \PYG{n}{get\PYGZus{}df}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{head}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{body} \PYG{o}{=} \PYG{n}{get\PYGZus{}df}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{body}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{legs} \PYG{o}{=} \PYG{n}{get\PYGZus{}df}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{leg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{amount}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{figure} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{figure}\PYG{p}{,} \PYG{n}{head}\PYG{p}{,} \PYG{n}{legs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{legs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{upper\PYGZus{}limb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{body}\PYG{p}{]}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{del} \PYG{n}{head}\PYG{p}{,} \PYG{n}{legs}\PYG{p}{,} \PYG{n}{upper\PYGZus{}limb}\PYG{p}{,} \PYG{n}{body}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following file depicts the results of this transformation. The row marked in yellow corresponds to the \sphinxstyleemphasis{figure} with
\sphinxstyleemphasis{item\_id} 77. When the values of this column are compared with the elementary csv files shown at the beginning, the
values are observed to have been combined correctly. The file created in this way contains all 21 attributes of a figure
per row.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.900\linewidth]{{merged_figure_csv}.png}\hspace*{\fill}}


\bigskip\hrule\bigskip



\subsubsection{Identify rejected items}
\label{\detokenize{source/Examples/example04:identify-rejected}}\label{\detokenize{source/Examples/example04:identify-rejected-items}}
\sphinxAtStartPar
Finally, how rejected workpieces can be identified is described. In the quality\_check function, the \sphinxstyleemphasis{item\_id} of
rejected items is stored globally. In the last step of the concatenation process described above, this global index set
can be used to filter the items whose \sphinxstyleemphasis{item\_id} appears in this set. Similarly, if the difference set is formed instead
of the intersection set, nonrejected items can be obtained.

\sphinxAtStartPar
Alternatively, global attributes can be avoided if further process steps follow after the station at which workpieces
are declared to be rejects. First, the item\_ids of all workpieces created by a source (\sphinxstyleemphasis{station\_id} = \sphinxhyphen{}1) are summarized
in a set. Analogously, an index set can be created that contains all item\_ids of items that have passed a specific
station. By forming the difference set, one receives all item\_ids of workpieces that represent rejects. With this set,
as described above, the rejected workpieces can be identified.


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{e}
\item\relax\sphinxstyleindexentry{environment}\sphinxstyleindexpageref{source/API/api:\detokenize{module-environment}}
\item\relax\sphinxstyleindexentry{estimator}\sphinxstyleindexpageref{source/API/api:\detokenize{module-estimator}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}